## malloc

我们分配内存时使用的 `malloc` 函数其实不是实现在操作系统里的，而是在标准库中实现的。当我们调用 `malloc` 时实际上是标准库在为我们申请内存。

这里值得注意的是，我们平时在C语言中使用 `malloc` 只是内存分配器的一种，实际上有很多内存分配器，像 `tcmalloc`，`jemalloc` 等等，它们都有各自适用的场景，对于高性能程序来说使用满足特定要求的内存分配器是至关重要的。



我们先来看一下程序在内存中是什么样的：

<img src="assets/v2-f86043a1e75ded759e42d415afb1a197_1440w.jpeg" alt="v2-f86043a1e75ded759e42d415afb1a197_1440w" style="zoom:33%;" />



在堆区和栈区之间有一片空白区域，栈区和堆区的增长需要占用原来的空白区域。

`malloc` 内存不足时要向操作系统申请内存，操作系统才是真大佬，`malloc` 不过是小弟，对每个进程，操作系统 (类Unix系统) 都维护了一个叫做 `brk` 的变量，`brk` 发音 `break`，这个 `brk` 指向了堆区的顶部。

操作系统提供了一个叫做 `brk` 的系统调用，这个 `brk()` 系统调用就是用来增加或者减小堆区的。除了 `brk`，`sbr、mmap` 系统调用也可以实现同样的目的，`mmap` 也更为灵活，但该函数并不是本文重点，就不在这里详细讨论了。

<img src="assets/v2-d332f6abe81dc848b62cc2f1c111f861_1440w.jpeg" alt="v2-d332f6abe81dc848b62cc2f1c111f861_1440w" style="zoom:60%;" />



## 虚拟内存

**但是，上述过程根本就没有涉及到哪怕一丁点物理内存。**

实际上，进程看到的内存都是假的，是操作系统给进程的一个幻象，即著名的**虚拟内存**。

所谓虚拟内存就是假的、不是真正的物理内存，虚拟内存是给进程用的，操作系统维护了虚拟内存到物理内存的映射，当 `malloc` 返回后，程序员申请到的内存就是虚拟内存。**此时操作系统根本就没有真正的分配物理内存。**

只有当我们真正使用这段内存时，这时会产生一个缺页错误，操作系统捕捉到该错误后开始真正的分配物理内存，操作系统处理完该错误后我们的程序才能真正的读写这块内存。



### 为啥要设虚拟内存

1. 解耦，对进程屏蔽了底层的物理RAM和磁盘，提供了更加简洁和易用的接口以及更加复杂的功能，用户程序无需关心底层如何实现
2. 并向进程提供了远超物理内存大小的内存空间
3. 为不同进程提供互相隔离的内存，每个进程都有各自的虚拟内存，某进程 X 不可随意指定个地址就开始读写，提高安全性&并发性

<img src="assets/v2-ea531f482dd21ee5dee88959660e3be3_1440w.jpeg" alt="v2-ea531f482dd21ee5dee88959660e3be3_1440w" style="zoom:60%;" />



## 总结

现在，这个故事就可以完整讲出来了，当我们调用 `malloc` 申请内存时：

1. `malloc` 开始搜索空闲内存块，如果能找到一块大小合适的就分配出去
2. 如果 `malloc` 找不到一块合适的空闲内存，那么调用 `brk` 等系统调用扩大堆区从而获得更多的空闲内存
3. `malloc` 调用 `brk` 后开始转入内核态，此时操作系统中的虚拟内存系统开始工作，扩大进程的堆区，注意额外扩大的这一部分内存仅仅是虚拟内存，操作系统并没有为此分配真正的物理内存
4. `brk` 执行结束后返回到 `malloc`，从内核态切换到用户态，`malloc` 找到一块合适的空闲内存后返回
5. 程序员拿到新申请的内存，程序继续
6. 当有代码读写新申请的内存时系统内部出现缺页中断，此时再次由用户态切换到内核态，操作系统此时真正的分配物理内存，之后再次由内核态切换回用户态，程序继续。



# 参考

[码农的荒岛求生 - 申请内存时底层发生了什么？](https://zhuanlan.zhihu.com/p/367386292)