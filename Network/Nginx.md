## Nginx 是如何实现高并发的？

异步，非阻塞，使用了epoll 和大量的底层代码优化。

如果一个 `server` 采用一个进程负责一个 `request` 的方式，那么进程数就是并发数。正常情况下，会有很多进程一直在等待中。

而 `Nginx` 采用一个 `master` 进程，多个 `woker` 进程的模式。

- `master` 是管理进程，它长期处于 `sleep` 状态，并不参与请求的处理，因此几乎不消耗服务器的IT资源
- 同时 `master` 进程也负责监控 `woker` 的状态，保证高可靠性
- `woker` 进程一般设置为跟 `CPU` 核心数一致。`nginx` 的 `woker` 进程在同一时间可以处理的请求数只受内存限制，可以处理多个请求。
- `worker` 是 `master` 的子进程，继承了父进程已经打开的端口
- `Nginx` 的异步非阻塞工作方式把等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。



每进来一个请求，会有一个 `worker` 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发`request`，并等待请求返回。这个处理的 `worker` 会在发送完请求后，注册一个事件："如果 `upstream` 返回了，告诉我一声，我再接着干"。于是他就休息去了。

此时，如果再有请求进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，`worker` 才会来接手，这个请求才会接着往下走。



## 为什么 Nginx 不使用多线程？

 首先，作为高性能负载均衡，稳定性非常重要。由于多线程共享同一地址空间，一旦出现内存错误，所有线程都会被内核强行终止，这会降低系统的可用性；

 其次，Nginx的模块化设计允许第三方代码嵌入到核心流程中执行，这虽然大大丰富了Nginx生态，却也引入了风险。

因此，Nginx宁肯选用多进程模式使用多核CPU，而只以多线程作为补充。



#### 参考

[民工哥 - Nginx 如何实现高并发？常见的优化手段有哪些](https://mp.weixin.qq.com/s/aM7n3C8m-YydNBlJhUXprA)

[NGINX开源社区](https://zhuanlan.zhihu.com/p/420043253)