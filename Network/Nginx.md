## Nginx 是如何实现高并发的？

异步，非阻塞，使用了epoll 和大量的底层代码优化。

如果一个 `server` 采用一个进程负责一个 `request` 的方式，那么进程数就是并发数。正常情况下，会有很多进程一直在等待中。

而 `Nginx` 采用一个 `master` 进程，多个 `woker` 进程的模式。

- `master` 进程主要负责收集、分发请求。每当一个请求过来时，`master` 就拉起一个 `worker` 进程负责处理这个请求。
- 同时 `master` 进程也负责监控 `woker` 的状态，保证高可靠性
- `woker` 进程一般设置为跟 `CPU` 核心数一致。`nginx` 的 `woker` 进程在同一时间可以处理的请求数只受内存限制，可以处理多个请求。
- `Nginx` 的异步非阻塞工作方式把等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。



每进来一个请求，会有一个 `worker` 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发`request`，并等待请求返回。那么，这个处理的 `worker` 很聪明，他会在发送完请求后，注册一个事件："如果 `upstream` 返回了，告诉我一声，我再接着干"。于是他就休息去了。

此时，如果再有请求进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，`worker` 才会来接手，这个请求才会接着往下走。



## 为什么 Nginx 不使用多线程？

Apache: Linux下支持 多进程 / 多进程+多线程 两种模式。可以配置最大进程、线程数，每个进程/线程都会为其分配 CPU和内存，线程数过大会耗光服务器资源。

Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）(epoll)，不会为每个请求分配 CPU 和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。





#### 参考

[民工哥 - Nginx 如何实现高并发？常见的优化手段有哪些](https://mp.weixin.qq.com/s/aM7n3C8m-YydNBlJhUXprA)