#### Go VS JAVA

##### Go

- **少即是多**。
- 语法简单，清晰，上手难度低，较短的学习曲线，提高开发效率
- 并发简单，语言层面支持并发，这个就是Go最大的特色。可以很容易的写出高并发的服务端
- 部署简单，编译成二进制就可以运行。配合容器很容易做规模化部署、伸缩
- 谷歌背书，开源
- 杀手级应用：docker，k8s
- 泛型迟迟才推出、错误处理很丑陋、map缩容至今没有实现，生态不完善、很多库未经大规模实践验证
- Go 其实是对 C 的优化，简化了语法，增加了自动 GC 等，目标并不是与 JAVA 对标

##### JAVA

- 理论体系成熟，设计模式、面向对象等
- 生态丰富



#### 带缓冲 channel 是怎么判断为空的

`channel` 内部有个 `qcount` 字段，记录了队列内的元素个数。判断 `qcount == 0` 即可



#### 什么是逃逸分析？

编译器在编译时会判断一个变量的作用域有没有跑出函数范围，这个叫逃逸分析，主要是用来判断把一个变量放在栈上还是放在堆上。如果变量的作用域没有逃出函数范围，就可以分配在栈上，否则就得分配在堆上。



#### Go为什么这么久才支持泛型？

设计者认为加入泛型不是很紧急



#### go中怎么控制协程的顺序

信号量 / 锁 / 队列（channel)



#### 方法里指针接收者和值接收者的区别，为什么设计了两种

1. 注意 go 里 **方法** 和 **函数** 的区别。
   1. 方法有接收者 `func (a int) Inc()`，
   2. 函数没有接收者 `func Inc(a int)`
2. 方法可视为特殊的函数。因此方法的接受者为指针还是值，其实就是函数传参有传值和传引用2个的区别，关系到实例是否被复制。
   1. 即 `func Inc(a int)` 和  `func Inc(a *int)` 的区别
3. 如果你希望修改原实例，或者实例体积较大，复制代价很大，就使用指针接收者。否则应用值接收者。



#### 除了 pprof，还有哪些性能分析工具？

gdb、delve、perf

