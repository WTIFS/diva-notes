#### Go VS JAVA

##### Go

- **少即是多**。
- 语法简单，清晰，上手难度低，较短的学习曲线，提高开发效率
- 并发简单，语言层面支持并发，这个就是Go最大的特色。可以很容易的写出高并发的服务端
- 部署简单，编译成二进制就可以运行。配合容器很容易做规模化部署、伸缩
- 谷歌背书，开源
- 杀手级应用：docker，k8s
- 泛型迟迟才推出、错误处理很丑陋、map缩容至今没有实现，生态不完善、很多库未经大规模实践验证
- Go 其实是对 C 的优化，简化了语法，增加了自动 GC 等，目标并不是与 JAVA 对标

##### JAVA

- 理论体系成熟，设计模式、面向对象等
- 生态丰富



##### 带缓冲 channel 是怎么判断为空的

`channel` 内部有个 `qcount` 字段，记录了队列内的元素个数。判断 `qcount == 0` 即可



##### 什么是逃逸分析？

编译器在编译时会判断一个变量的作用域有没有跑出函数范围，这个叫逃逸分析，主要是用来判断把一个变量放在栈上还是放在堆上。如果变量的作用域没有逃出函数范围，就可以分配在栈上，否则就得分配在堆上。



##### Go里什么情况下变量会发生逃逸？

1. 变量在函数外被引用
2. 变量被函数返回
3. 变量被闭包引用
4. 可以使用 Go 的内置工具 `go build -gcflags="-m"` 这个 `-m` 参数来查看哪些变量发生了逃逸



##### Go为什么这么久才支持泛型？

设计者认为加入泛型不是很紧急



##### Go中怎么控制协程的顺序

信号量 / 锁 / 队列（channel)



##### 方法里指针接收者和值接收者的区别，为什么设计了两种

1. 注意 go 里 **方法** 和 **函数** 的区别。
   1. 方法有接收者 `func (a int) Inc()`，
   2. 函数没有接收者 `func Inc(a int)`
2. 方法可视为特殊的函数。因此方法的接受者为指针还是值，其实就是函数传参有传值和传引用2个的区别，关系到实例是否被复制。
   1. 即 `func Inc(a int)` 和  `func Inc(a *int)` 的区别
3. 如果你希望修改原实例，或者实例体积较大，复制代价很大，就使用指针接收者。否则应用值接收者。



##### 除了 pprof，还有哪些性能分析工具？

gdb、delve、perf、pprof 的 trace



##### 有哪些阻塞场景

其实就是问哪些代码可以阻塞程序向下继续执行，这些代码有：channel/select；sync 包下的原子量和互斥量；sleep；网络IO（如http.Get）；文件IO；for/goto 循环



##### 有哪些 panic 无法被 recover 捕获

并发读写map；死锁；栈溢出；OOM



##### 代码执行顺序

先初始化导入的包 import，然后是常量 const、变量 var、init 函数



##### Go 里面有哪些并发安全的类型？

sync包下的锁、信号量；channel



##### 普通类型并发安全的有哪些？

由一条机器指令完成赋值的类型并发赋值是安全的，这些类型有：byte，bool、整型、浮点型、字符型、指针、函数



##### atomic 是什么原理？

CAS



##### 怎样减少 GC？

1.19 前用 GOGC 变量控制GC阈值比例；1.19 后用 GOMEMLIMIT



##### 多个字符串拼接过程是什么样的？

为新的字符串创建一个新的内存空间，并将原来的两个字符串的内容复制到新的内存空间中。多个字符串拼接可使用 `strings.Builder` ，更高效，原理为预分配足够的内存空间来避免加号的每次生成新字符串



##### 最有学什么新的东西

《Golang设计与实现》《Redis设计与实现》



##### Go 的最新版本有哪些特性

1.14 优化 timer；1.18 支持泛型；。1.19 支持 GOMEMLIMIT 变量控制 GC 堆大小阈值；1.20 实验特性：arena 手动管理内存

