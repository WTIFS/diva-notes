[TOC]



##### Go VS JAVA

###### Go

- **少即是多**。
- 语法简单，清晰，上手难度低，较短的学习曲线，提高开发效率
- 并发简单，语言层面支持并发，这个就是Go最大的特色。所有的异步操作都是同步的写法，可以很容易的写出高并发的服务端
- 部署简单，编译成二进制就可以运行。配合容器很容易做规模化部署、伸缩
- 谷歌背书，开源
- 杀手级应用：docker，k8s
- 泛型迟迟才推出、错误处理很丑陋、map缩容至今没有实现
- 生态不完善、很多库未经大规模实践验证；很多领域没有生态，如游戏、图像、计算、嵌入式等
- Go 其实是对 C 的优化，简化了语法，增加了自动 GC 等，目标并不是与 JAVA 对标

###### JAVA

- 理论体系成熟，设计模式、面向对象等
- 生态丰富



##### 带缓冲 channel 是怎么判断为空的

`channel` 内部有个 `qcount` 字段，记录了队列内的元素个数。判断 `qcount == 0` 即可



##### 什么是逃逸分析？

编译器在编译时会判断一个变量的作用域有没有跑出函数范围，这个叫逃逸分析，主要是用来判断把一个变量放在栈上还是放在堆上。如果变量的作用域没有逃出函数范围，就可以分配在栈上，否则就得分配在堆上。



##### Go里什么情况下变量会发生逃逸？

1. 变量在函数外被引用
2. 变量被函数返回
3. 变量被闭包引用
4. 可以使用 Go 的内置工具 `go build -gcflags="-m"` 这个 `-m` 参数来查看哪些变量发生了逃逸



##### Go为什么这么久才支持泛型？

设计者认为加入泛型不是很紧急



##### Go中怎么控制协程的顺序

信号量 / 锁 / 队列（channel)



##### 方法里指针接收者和值接收者的区别，为什么设计了两种

1. 注意 go 里 **方法** 和 **函数** 的区别。
   1. 方法有接收者 `func (a int) Inc()`，
   2. 函数没有接收者 `func Inc(a int)`
2. 方法可视为特殊的函数。因此方法的接受者为指针还是值，其实就是函数传参有传值和传引用2个的区别，关系到实例是否被复制。
   1. 即 `func Inc(a int)` 和  `func Inc(a *int)` 的区别
3. 如果你希望修改原实例，或者实例体积较大，复制代价很大，就使用指针接收者。否则应用值接收者。



##### 除了 pprof，还有哪些性能分析工具？

gdb、delve、perf、pprof 的 trace



##### 有哪些阻塞场景

其实就是问哪些代码可以阻塞程序向下继续执行，这些代码有：channel/select；sync 包下的原子量和互斥量；sleep；网络IO（如http.Get）；文件IO；for/goto 循环



##### 有哪些 panic 无法被 recover 捕获

并发读写map；死锁；栈溢出；OOM



##### 代码执行顺序

先初始化导入的包 import，然后是常量 const、变量 var、init 函数



##### Go 里面有哪些并发安全的类型？

sync包下的锁、信号量；channel



##### 普通类型并发安全的有哪些？

由一条机器指令完成赋值的类型并发赋值是安全的，这些类型有：byte，bool、整型、浮点型、字符型、指针、函数



##### atomic 是什么原理？

CAS



##### 多个字符串拼接过程是什么样的？

为新的字符串创建一个新的内存空间，并将原来的两个字符串的内容复制到新的内存空间中。多个字符串拼接可使用 `strings.Builder` ，更高效，原理为预分配足够的内存空间来避免加号的每次生成新字符串



##### 最近有学什么新的东西

《Golang设计与实现》《Redis设计与实现》



##### Go 的最新版本有哪些特性

1.14 优化 timer；1.18 支持泛型；1.19 支持 GOMEMLIMIT 变量控制 GC 堆大小阈值；1.20 实验特性：arena 手动管理内存



##### 怎样减少 GC

可通过环境变量调整频率，也可优化程序自身逻辑。环境变量：1.19 前用 GOGC 变量控制GC阈值比例；1.19 后用 GOMEMLIMIT



##### Go 应用性能优化

1. 减少变量逃逸，尽量使用局部变量，在栈上分配对象
2. 切片等结构提前分配足够容量
3. 减少对象分配数量，复用对象；或使用 sync.Pool
4. 减少协程数量，复用协程处理多个任务
5. 减小锁粒度，减少锁竞争
6. pprof 分析程序性能瓶颈



##### fasthttp 做了哪些优化提高性能？有哪些坑？

1. 使用 sync.Pool 复用 Context 对象
2. 使用 slice 代替 map 存储 kv，清理时不用释放内存，只需将长度修改为 0
3. 大量使用可修改的 []byte 而非 string
4. 使用 unsafe 包避免 string 和 byte 互转
5. 坑：如果起了协程修改对象、该对象被放回 sync.Pool 后，被下一个请求取出使用，会出现并发读写情况、污染下一个请求
