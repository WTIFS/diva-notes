## 调度 schedule

`G` 是如何被轮换并执行的呢？

1. 总体思路是：依次从 `P` 的本地 `G` 队列、全局 `G` 队列取
2. 调度器每调度 `61` 次，从全局队列里取一次 `G`（以避免全局队列里有的 `G` 始终不被取出、饿死）
3. 调用 `runqget` 函数从 `P` 本地的运行队列中查找待执行的 `G`
4. 调用 `findrunnable` 函数从其他地方取 `G`（依次从本地队列、全局队列、netpoll、从其他 `P` 里偷窃取 `G`）
   - 先再次尝试从本地队列获取 `G`
   - 去全局队列获取（因为前面仅仅是1/61的概率）
   - 执行 `netpoll`，检查是否有 `IO` 就绪的 `G`
   - 如果还是没有，那么随机选择一个 `P`，偷其 `runqueue` 里的一半。
     - 这里的随机用到了一种质数算法，保证既随机，每个 `P` 又都能被访问到
   - 偷窃前会将 `M` 的自旋状态设为 `true`，偷窃后再改回去
   - 如果多次尝试偷 `P` 都失败了，`M` 会把 `P` 放回 `sched` 的 空闲 `P` 数组，自身休眠（放回空闲 `M` 列表）
5. `wakep`, 另一种情况是，`M` 太忙了，如果 `P` 池子里有空闲的 `P`，会唤醒其他 `sleep` 状态的 `M` 一起干活。如果没有 `sleep` 状态的 `M`，`runtime` 会新建一个 `M`。
6. `execute`，执行代码。



#### schedule

```go
// runtime/proc.go
// 找出一个 G 来执行
func schedule() {

// STW检查
top:
    if sched.gcwaiting != 0 {
        gcstopm()
        goto top
    }

    // 检查定时器
    checkTimers(pp, 0)
  
    // 进入 GC MarkWorker 工作模式
    if gp == nil && gcBlackenEnabled != 0 {
        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
        if gp != nil {
            tryWakeP = true
        }
    }
  
    // 每 tick 61次，从全局队列里取 G
    if gp == nil {
        if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
            lock(&sched.lock)
            gp = globrunqget(_g_.m.p.ptr(), 1)
            unlock(&sched.lock)
        }
    }

    // 从本地队列里取 G，优先使用 P.runnext 字段
    if gp == nil {
        gp, inheritTime = runqget(_g_.m.p.ptr())
    }
    
    // 通过 findrunnable 函数从其他可能得地方寻找可执行 G
    if gp == nil {
        gp, inheritTime = findrunnable() // blocks until work is available
    }
    
  
    // 执行任务函数 
    execute(gp, inheritTime)
}
```



#### findrunnable

依次从 本地队列、全局队列、netpoll、其他 `P` 获取可运行的 `G`。偷窃优先级最低，因为会影响其他 `P` 执行（需要加锁）。

```go
// 寻找可执行的 G
// Tries to steal from other P's, get g from local or global queue, poll network.
func findrunnable() (gp *g, inheritTime bool) {
    now, pollUntil, _ := checkTimers(_p_, 0) // 检查 P 中的定时器，参考 Timer 的实现那篇文章
    // 本地队列
    if gp, inheritTime := runqget(_p_); gp != nil {
        return gp, inheritTime
    }

    // 本地队列里没G，从全局队列里取
    if sched.runqsize != 0 {
        lock(&sched.lock)          // 全局队列需要加锁        
        gp := globrunqget(_p_, 0)  // 从全局队列队头弹出；另外会分一部分 G 给当前 P
        unlock(&sched.lock)
        if gp != nil {
            return gp, false
        }
    }
  
    // 网络协程
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
        // 略
    }

    // 从其他 P 偷窃
    for i := 0; i < 4; i++ {
        // 这里的随机用到了一种质数算法，保证既随机，每个P又都能被访问到
        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
            stealRunNextG := i > 2 // first look for ready queues with more than 1 g
            p2 := allp[enum.position()]
            if gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {
                return gp, false
            }
        }
    } 
}
```



#### globrunqget

在检查全局队列时，除返回一个可用 `G` 外，还会批量转移一批 `G` 到 `P` 的本地队列。毕竟不能每次加锁去操作全局队列。

```go
// 从全局队列列取 G
// 另外还会分一部分 G 给 P（分的 G 个数为 Min（全局队列长度/P个，或者P本地队列/2））
func globrunqget(_p_ *p, max int32) *g {
    if sched.runqsize == 0 {
        return nil
    }

    // 分给 P 的 G 个数为（全局队列长度/P个数，P本地队列长度/2，二者最小值）
    // 将全局队列按 P 个数等分
    n := sched.runqsize/gomaxprocs + 1
    if n > sched.runqsize {
        n = sched.runqsize
    }
    // 不能超过 runq 数组长度的一半
    if n > int32(len(_p_.runq))/2 {
        n = int32(len(_p_.runq)) / 2
    }

    sched.runqsize -= n    // 调整计数

    gp := sched.runq.pop() // 从全局队列头部弹出 G
    n--
    for ; n > 0; n-- {     // 分 n 个 G 到当前 P 的本地队列
        gp1 := sched.runq.pop()
        runqput(_p_, gp1, false)
    }
    return gp
}
```





## 调度时机

- 新建 `M` 后，`mstart` 里触发 `schedule`
- 新建 `G` 后（`go func`）
- 阻塞性系统调用，比如文件 IO，网络IO
  - `Golang` 重写了所有系统调用，在系统调用里加入了调度逻辑（更改 `G`状态、`M` 和`P` 解绑、 `schedule `等）
- `sysmon` 会定期检查运行超长的任务，进行调度
- 主动调用 `runtime.Gosched()`，这个很少见，一般调试才用





# 优点

- 调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换
- 不需要频繁的进行内存的分配与释放。在用户态维护着一块大的内存池， 不直接调用系统的 `malloc` 函数（除非内存池需要改变）
- 另一方面充分利用了多核的硬件资源，近似的把若干 `goroutine` 均分在物理线程上
- 再加上本身 `goroutine` 的超轻量，以上种种保证了 `go` 调度方面的性能