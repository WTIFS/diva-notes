# Go内存管理

Go 的 `runtime` 抛弃了传统的内存分配方式，改为自主管理，这样可以完成内存池、预分配等操作，不会每次内存分配都需要进行系统调用。另外也可以更好的配合垃圾回收。



# 基本策略

1. 每次从操作系统直接申请一大块内存，而不是用一次调用一次，减少系统调用。
2. 将申请到的大块内存按特定大小预先切分成小块，构成链表。
3. 为对象分配内存时，只需从大小合适的链表中提取一个小块即可。
4. 回收对象内存时，放回原链表，以便复用。
5. 如闲置内存过多，归还部分给操作系统，降低整体开销。



# 堆内存管理

我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。堆内存管理主要是3部分，分别是分配内存块，回收内存块和组织内存块。

在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配任何内存。当发现内存申请的时候，堆内存就会从未分配内存分割出一个小内存块(block)，然后用链表把所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)、是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。

释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中优先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。

随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。



# Tmalloc

TCMalloc 是 Thread Cache Malloc的简称，是Go内存管理的起源，Go的内存管理是借鉴了TCMalloc，随着Go的迭代，Go的内存管理与TCMalloc不一致地方在不断扩大，但其主要思想、原理和概念都是和TCMalloc一致的。





## 内存块

分配器将其管理的内存块分为两种。

- span：由多个连续页组成的大块内存（类似快递车）
- object：将 span 按不同的规格切分成多个小块，每个小块可储存一个对象（类似快递盒）

```go
// malloc.go
_PageShit = 13
_PagegSize = 1 << _PageShft // 一页8KB

// mheap.go
type mspan struct {
    next     *mspan     // 双向链表
    prev     *mspan
    start    pageID     // 起始页地址 (=address >> _PageShift)
    npages   uintptr    // 页数
    freelist gclinkptr  // 待分配的 object 链表
}
```

用于储存对象的 object，按 8 字节倍数分为 n 种。比如大小为 24 字节的可用来存储范围在17 ~ 24 字节的对象。这种方式虽然会造成一些浪费，但分配器只需要处理有限几种规格的小块内存，优化了分配和复用管理策略。

若对象大小超过特定阈值 (32KB)，会被当做大对象处理。







## 参考

[零壹技术栈 - 详解Go语言的内存模型及堆的分配管理](https://zhuanlan.zhihu.com/p/76802887)
