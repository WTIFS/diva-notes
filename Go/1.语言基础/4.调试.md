[TOC]

目前 `Go` 语言支持 `GDB`、`LLDB`、`Delve` 调试器，但只有 `Delve` 是专门为 `Go` 语言设计开发的调试工具（比如 `Delve` 优化了 `error, channel` 结构体的打印、针对协程栈扩容做了优化等），所以使用 `Delve`可以轻松调试 `Go` 汇编程序。

delve 的安装：`go install github.com/go-delve/delve/cmd/dlv@latest`



# dlv 使用

dlv 可以通过如下3种方式来进行：

1. debug: `dlv debug {xxx.go}`，调试 go 源码文件
1. attach: `dlv attach {pid}`，可以调试正在运行的进程
1. api: `./dlv --listen=127.0.0.1:26953 --headless=true --api-version=2 --check-go-version=false --only-same-user=false attach {pid}`，可以远程调试



以 debug  方式为例，看一看如何调试 `Go` 源码

大家都知道向一个 `nil` 的切片追加元素，不会有任何问题，在源码中是怎么实现的呢？接下来我们使用 `dlv` 调试跟踪一下，先写一个 `playground.go`:

```go
package main

import "fmt"

func main() {
    var s []int
    s = append(s, 1)
    fmt.Println(s)
}
```



进入命令行包目录，然后输入 `dlv debug` 进入调试

```bash
dlv debug playground.go
```



因为这里我们想看到 `append` 的内部实现，所以在 `append` 那行加上断点，执行如下命令：

```bash
(dlv) break main.go:7
Breakpoint 1 set at 0x100255268 for main.main() ./playground.go:7
```



执行 `continue` 命令，运行到断点处：

```go
(dlv) continue
> main.main() ./playground.go:7 (hits goroutine(1):1 total:1) (PC: 0x100255268)
     2: 
     3: import "fmt"
     4: 
     5: func main() {
     6:     var s []int
=>   7:     s = append(s, 1)
     8:     fmt.Println(s)
     9: }

```



接下来我们执行 `disassemble` 反汇编命令查看 `main` 函数对应的汇编代码：

```assembly
(dlv) disassemble
TEXT main.main(SB) /.../playground.go
        ...
=>      playground.go:7 0x10aba57*      488d05a2740000  lea rax, ptr [rip+0x74a2]
        ...
        playground.go:7 0x100255280     d097fe97        CALL runtime.growslice(SB)
        playground.go:8 0x1002552b8     76a0fd97        CALL runtime.convTslice(SB)
```



从以上内容我们看到调用了 `runtime.growslice` 方法，我们在这里加一个断点：

```bash
(dlv) break runtime.growslice
Breakpoint 2 set at 0x1001fb1d0 for runtime.growslice() /usr/local/go/src/runtime/slice.go:166
```



之后我们再次执行  `continue`  执行到该断点处：

```go
(dlv) continue
> runtime.growslice() /usr/local/go/src/runtime/slice.go:166 (hits goroutine(1):1 total:1) (PC: 0x1001fb1d0)
Warning: debugging optimized function
   161: // NOT to the new requested capacity.
   162: // This is for codegen convenience. The old slice's length is used immediately
   163: // to calculate where to write new values during an append.
   164: // TODO: When the old backend is gone, reconsider this decision.
   165: // The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
=> 166: func growslice(et *_type, old slice, cap int) slice {
   167:         if raceenabled {
   168:                 callerpc := getcallerpc()
   169:                 racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice))
   170:         }
```

之后就是不断的单步调试可以看出来切片的扩容策略；到这里大家也就明白了为啥向 `nil` 的切片追加数据不会有问题了，因为在容量不够时会调用 `growslice` 函数进行扩容



## 常用命令

`dlv attach $pid`：调试指定 pid 进程



`goroutines` 命令：

通过 `goroutines` 命令（简写 `grs`），我们可以查看所有协程

通过 `goroutine/gr` 命令查看当前协程；`gr {goid}` 进入置顶协程

```
(dlv) grs
* Goroutine 1 - User: ./main.go:7 main.main (0x10aba6f) (thread 218565)
  Goroutine 2 - User: /usr/local/opt/go/libexec/src/runtime/proc.go:367 runtime.gopark (0x1035232) [force gc (idle)]
  Goroutine 3 - User: /usr/local/opt/go/libexec/src/runtime/proc.go:367 runtime.gopark (0x1035232) [GC sweep wait]
  Goroutine 4 - User: /usr/local/opt/go/libexec/src/runtime/proc.go:367 runtime.gopark (0x1035232) [GC scavenge wait]
  Goroutine 5 - User: /usr/local/opt/go/libexec/src/runtime/proc.go:367 runtime.gopark (0x1035232) [finalizer wait]
```



`stack`  命令：通过 `stack`  命令（简写bt），我们可查看当前函数调用栈信息：

```
(dlv) bt
0  0x0000000001047e15 in runtime.growslice
   at /usr/local/opt/go/libexec/src/runtime/slice.go:183
1  0x00000000010aba6f in main.main
   at ./main.go:7
2  0x0000000001034e13 in runtime.main
   at /usr/local/opt/go/libexec/src/runtime/proc.go:255
3  0x000000000105f9c1 in runtime.goexit
   at /usr/local/opt/go/libexec/src/runtime/asm_amd64.s:1581
```



`regs` 命令：查看全部的寄存器状态，可以通过单步执行来观察寄存器的变化

`locals` 命令：查看当前函数所有变量值

`help` 命令：列出所有命令



其实很多 Golang IDE 的 debugger 使用的就是 dlv，以  IntelliJ IDEA 的 为例，点击 debug 图标后，可以在控制台输出看到它使用的 dlv 路径：
```bash
"/Users/xxx/Library/Application Support/JetBrains/IntelliJIdea2023.1/plugins/go-plugin/lib/dlv/macarm/dlv" --listen=127.0.0.1:51683 --headless=true --api-version=2 --check-go-version=false --only-same-user=false exec /Users/xxx/Library/Caches/JetBrains/IntelliJIdea2023.1/tmp/GoLand/___go_build_github_com_WTIFS_project_diva_src_myGo --
```

 其中的 `--listen` 参数表示将 dlv 作为一个服务启动，可通过其后面指定的地址交互。这样可以在生产环境机器上启动 dlv，然后在 IDE 的 debugger 里配置这个地址，就可以远程 debug、短点调试了





# 基本原理

delve 的源码可以看这里：https://github.com/go-delve/delve

其基本原理是：

1. 将断点这一地址的指令覆盖掉，替换成一条新的指令：当执行该指令时，线程停止运行并发送信号
2. 将 dlv 进程作为被调试程序的父进程，子进程执行到断点时会发信号给 dlv 进程，dlv 进程等待用户的进一步指令



# 架构

Delve的整体架构如下：

- UI Layer，直接与用户交互，接受用户输入的指令；各 IDE 实现的就是这层
- （Service Layer）抽象出的一个服务层，作为 UI 和 Symbolic 层中间的层，通过 RPC 交互
  - 通过这样的架构可以分离客户端和被调试程序，从而支持远端调试
- Symbolic Layer，转换源码和内存地址，拥有代码行号、数据类型、变量名等信息
- Target Layer，控制被调试进程，读写目标进程的寄存器

![img](assets/dlv_arch.webp)



## Symbol layer

编译器会向可执行文件中写入一些用于调试的信息，我们称为 debug symbol，Symbolic Layer 所做的事情就是从可执行文件中读取这些符号

Go语言采用的 debug symbol 规范是 DWARFv4 (2018年)，DWARF 中比较重要的有三种：

- debug_line：这是一个表，它将指令地址映射到文件:行号
- debug_frame：堆栈解压信息。
- debug_info：描述程序中的所有函数、类型和变量

Delve通过 debug_info 找到函数名，通过 debug_line 找到某条指令对应的代码在哪个文件的哪一行，再通过 debug_frame 获取指令地址



## Target Layer

作用是控制目标进程。在delve 中提供了对 target layer 的三种实现方式：

- pkg/proc/native: 使用 os API call 控制目标进程， Linux 和Windows 的默认实现方式
- pkg/proc/core: 读取linuxs 的core dump 文件。
- pkg/proc/gdbserial: 通过 TCP/IP 连接服务器。采用的协议叫做 GDB Remote Serial Protocol，GDB的标准远程通信协议

这里展开看下 `pkg/proc/native/proc_linux.go`：

```go
// pkg/proc/native/proc_linux.go
func Attach(pid int, debugInfoDirs []string) (*proc.TargetGroup, error) {
    dbp := newProcess(pid) // 新建 dlv 进程
    dbp.execPtraceFunc(func() { err = ptraceAttach(dbp.pid) })
}

// pkg/proc/native/ptrace_linux.go
// 实际调用 linux 的 ptrace 命令
func ptraceAttach(pid int) error {
	  return sys.PtraceAttach(pid)
}
```



可以看到  linux 下的 dlv attach 命令实际调用了 linux 提供的 `ptrace` API。

ptrace 系统调从名字上看是用于进程跟踪的，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像 (包括寄存器)的值。其基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。



当我们用 dlv 设置断点时, dlv 会把断点处的指令修改成 int 3, 同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 int 3命令, 从而产生 SIGTRAP 信号. 由于 dlv 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 dlv, dlv 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点。
如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, dlv 就会先恢复断点处的指令, 然后执行对应的代码。



![img](assets/dlv2.png)




# 参考

[AsongGo - 分享如何阅读Go源码](https://mp.weixin.qq.com/s/c2yPBbDLjiSrpYP62p-uKQ)

[曹春晖 - Delve 调试器](https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-09-debug.html)

[mercury - Dlv 深入探究](https://zhuanlan.zhihu.com/p/364346530)

[日天不吃糖 - Delve的内部架构与实现](https://zhuanlan.zhihu.com/p/538725747)