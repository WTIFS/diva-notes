# goroutine 和 thread 的区别
谈到 `goroutine`，绕不开的一个话题是：它和 `thread` 有什么区别？

参考资料 [How Goroutines Work](https://blog.nindalf.com/posts/how-goroutines-work/) 告诉我们可以从三个角度区别：内存消耗、创建与销毀、上下文切换。

1. 内存占用
    - 创建一个 `goroutine` 的栈内存消耗为 `2 KB`，而 `thread` 占用 `1M` 以上空间
    -  对于一个用 `Go` 构建的 HTTP Server 而言，我们可以给每个请求创建一个 `goroutine` 。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很容易内存溢出。

2. 创建和销毀的开销
    - 线程的创建和销毀都会有巨大的开销，因为要从用户态切到内核态。通常解决的办法就是使用线程池，复用线程。
    - 而 `goroutine` 因为是由 `Go runtime` 负责管理的，是用户级的，不需要切换到内核级，创建和销毁的开销非常小。
    
3. 上下文切换
    - 当 `threads` 切换时，需要保存各种寄存器，以便将来恢复。
    - 而 `goroutines` 切换只需保存三个寄存器：`PC (Program Counter 程序计数器), SP (Stack Pointer 栈顶指针) and BP (Base Pointer 基数指针计数器)`。
    - 一般而言，线程切换会消耗 `1000-1500 ns`，`goroutine` 的切换约为 `200 ns`。因此，`goroutine` 切换成本比 `threads` 要小得多。
    - `Go` 调度器还有助于提高 `cache-line` 的效率和 `NUMA`。从 `OS` 的视角，`OS` 线程没有换，也就从来没有进入到等待状态，一直在同一个 `CPU` 核上。





# 用户级线程模型

线程分 **用户空间** 和 **内核空间** 的。

每个用户空间的线程需要关联到内核线程 `KSE (Kernel Scheduling Entity)` 上，OS调度时，调度到的是 `KSE`。`KSE` 被调度执行后，会映射到实际的用户线程，开始执行。

库调度器从进程的多个线程中选择一个线程，然后该线程和一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。



线程模型的实现，可以分为以下 3 种方式：



#### 内核级线程模型 (1: 1)

- 关键点: 完全靠操作系统调度
- 每个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做。应用程序对线程的创建、终止以及同步都基于内核提供的 系统调用API 来完成。
- 这个模型能够利用机器上的所有核心的优势，但是上下文切换非常慢，因为它需要切到内核态（trap through the OS）
- C++就是这种。



#### 用户级线程模型 (N: 1)

- 关键点: 完全靠自己调度
- 线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。这个模型可以很快的进行上下文切换，
- 无法充分利用多核系统（multi-core systems) 的优势（比如2个函数，本来可以在2个CPU上跑的，在该模型下如果指向同一个 `KSE`，则不能并行跑
- 接上，如果进程中的一个线程被阻塞，内核会由于不知道有多线程的存在，阻塞这个 `KSE` 上关联的所有线程。因此同一进程中只能同时有一个线程在运行



#### 两级线程模型 (M: N)

- 关键点: 自身调度与系统调度协同工作
- 这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应。
- 这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程 (`M`) 由程序本身的调度器调度，内核级的线程 (`KSE`) 由操作系统内核调度。
- 个人理解，这个模型会先创建 1:1 的用户级线程（即 `M`），每个用户线程再对应 N 个协程。协程不是绑定在线程上的，每次调度时可能会换线程，因此是 M: N。

