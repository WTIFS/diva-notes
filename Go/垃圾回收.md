# 概述
- 标记垃圾
  - 引用计数 - C++ / Python
  - 根可达 - Go / JAVA
- 常用的垃圾回收算法
  - Go 使用三色标记法
  - JVM 使用分代回收法
- 写屏障有两种写屏障及过程（插入写屏障，删除写屏障）
- 写屏障解决的问题（三色标记法错标或漏标问题）





# 垃圾标记算法

1. 引用计数法
2. 根可达算法



## 引用计数法 

在对象的结构体里额外内置一个计数器，当对象被引用时引用计数加一，解除引用时减一。当引用计数归零时，自动销毁对象。

以 Python 为例，其对象结构体为：

```python
typedef struct_object {
 int ob_refcnt;              // 引用计数
 struct_typeobject *ob_type;
} PyObject;
```

当执行创建对象、赋值、传参等操作时，引用 +1。销毁、赋新的值（旧值引用 -1）、脱离作用域等时机，引用 -1。



#### 优点

引用计数法有其明显的优点，如高效、实现逻辑简单、具备实时性。

1. 一旦一个对象的引用计数归零，内存就直接释放了。不用像其他机制等到特定时机。
2. 将垃圾回收随机分配到运行的阶段，正常程序的运行比较平稳，不像 Go 每隔一段时间做一次 GC。



#### 缺点

1. 循环引用，如 `a.next = b; b.next = a`。这是引用计数的致命伤，引用计数对此是无解的，因此必须使用其它的GC算法进行补充。

2. 维护计数麻烦。每个对象需要分配单独的空间来统计引用计数，增加空间占用量不说，需要对引用计数进行维护，在维护的时候很容易会出错。
3. 释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。



## 根可达算法
简单来讲，从根对象往下查找引用，可以查找到的引用标记成可达，直到算法结束之后，没有被标记的对象就是不可达的、未使用的，可以被回收。





# 垃圾回收算法

1. 标记 - 清除
   1. 会产生内存碎片
2. 复制
   1. 复制性能消耗大、STW 时间长
3. 标记-压缩
   1. 前两种的结合
4. 分代模型
5. 三色标记法



## 分代模型

JVM 做垃圾回收时使用的 GC 算法。将对象分为年轻代和老年代，年轻代使用复制算法，老年代使用标记压缩或者标记清除。

另外jdk1.8可以用上面的分代模型，也可以使用不分代模型，即G1、ZGC等。



## 三色标记法

三色标记法是传统标记 - 清除算法的一个改进，它是一个并发的 GC 算法。其实大部分的工作还是在标记垃圾，基本原理基于根可达

步骤：

1. 首先初始状态下所有对象都是白色的
2. 从根对象开始遍历所有对象，将遍历到的对象从白色集合放到灰色集合
3. 遍历灰色集合中的对象，将灰色对象引用的对象放到灰色集合里面，自身放进黑色集合
4. 重复 3 直到灰色集合为空
5. 在标记开始时会开启写屏障。然后在标记期间发生变化的对象，会被直接标记为灰色，重复上面操作
6. 清除所有白色对象



#### 三色标记的问题

1. 多标 (浮动垃圾)
   1. 假设现有 `A 黑 -> B 灰 -> C 白` 的引用，现正准备将 `C` 标记为灰
   2. 这时 `B` 解除了 对 `C` 的引用，那 `C` 虽然后面被标记为灰色，但它实际是应该被回收的
   3. 这种情况不碍事，大不了下次 GC 再收集
2. 漏标（悬挂指针）
   1. 还是 `A 黑 -> B 灰 -> C 白`，假设程序又新建了个 `A -> D` 的引用
   2. 因为 `A` 是黑色的，不会再被扫描，因此检测不到 `D`，`D` 会被视为白色而被清理，造成空指针异常
   3.  Golang 使用写屏障来解决这个问题





# 写屏障

Go 的写屏障和内存写屏障是两个概念，不要搞混了。

简单来说，Go 的写屏障就是编译器在函数执行时插了段代码（类似于栈扩容检测的代码），并用一个变量来标记是否开启了写屏障。

函数执行时，先判断一下这个写屏障的标记，如果为 `true`，就执行写屏障相关的逻辑。

写屏障主要有两种：Dijkstra 实现的插入写屏障，和 Yuasa 实现的删除写屏障。

Go 1.7 之前是用的是插入写屏障，1.7 之后这两种一起使用，称为混合写屏障。





# GC时机

1. 申请内存时会调用 `runtime.mallocgc`
2. 后台监控协程 `sysmon`

在上述两个时机会判断是否需要 `GC` ，判断条件是一个触发系数 `triggerRatio`。这个触发系数的计算比较绕，总体和 CPU使用率、内存占用增长率、上个触发系数有关。这个系数决定了触发 `GC` 的堆大小的阈值。

1. 



# 其他

##### 为什么 Go 不采用分代算法？

分代是假设多数对象在新生代的基础上的。 Go Team 由于实现了逃逸分析，可以规避大量堆对象的产生。另外分代也是有代价的，比如跨代引用，为了解决这个问题还需要设立 rset 集合。 go nuts有个邮件说明了问题，简单说团队认为分代的收益没那么大，依据是他们的一些测试。




#### 参考

> [逃出黑洞的光线 - 那位大神讲解一下golang gc机制](https://www.zhihu.com/question/403065438/answer/1426765597)
>
>[luoziyun - Go语言GC实现原理及源码分析](https://www.luozhiyun.com/archives/475)

