# map hash å†²çªçš„å¸¸è§è§£å†³æ–¹æ¡ˆ

1. å¼€æ”¾åœ°å€æ³•
   - æ”¾å…¥å…ƒç´ ï¼Œå¦‚æœå‘ç”Ÿå†²çªï¼Œå°±å¾€åæ‰¾æ²¡æœ‰å…ƒç´ çš„ä½ç½®
   - åº•å±‚æ•°æ®ç»“æ„å°±æ˜¯æ•°ç»„
   - `index := hash("xxx") % len(array); for (å†²çª) index++;`
   - å¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯**è£…è½½å› å­**ï¼Œå®ƒæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ä¸æ•°ç»„å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚å½“è£…è½½ç‡è¾¾åˆ° 100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦é€€åŒ–ä¸º ğ‘‚(ğ‘›) ï¼Œè¿™æ—¶éœ€è¦éå†æ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ ï¼Œæ‰€ä»¥åœ¨å®ç°å“ˆå¸Œè¡¨æ—¶ä¸€å®šè¦å…³æ³¨è£…è½½å› å­çš„å˜åŒ–ã€‚
2. é“¾è¡¨æ³• / æ‹‰é“¾æ³•
   - `hashcode` ç›¸åŒçš„ä¸²æˆé“¾è¡¨ã€‚`Goã€JAVA` é‡‡ç”¨çš„æ–¹æ³•
   - ä¸€èˆ¬æ•°æ®ç»“æ„ä¸ºæ•°ç»„+é“¾è¡¨
3. å†å“ˆå¸Œ
   - ç”¨å¦ä¸€ä¸ªæ–¹æ³•è®¡ç®— `hashcode`ã€‚å¸ƒè°·é¸Ÿè¿‡æ»¤å™¨ä½¿ç”¨çš„æ–¹æ³•
4. å…¬å…±æº¢å‡ºåŒº
   - å‘ç”Ÿå†²çªçš„å…ƒç´ ï¼Œä¸€å¾‹å¡«å…¥æº¢å‡ºè¡¨



# æ•°æ®ç»“æ„

Go è¯­è¨€è¿è¡Œæ—¶åŒæ—¶ä½¿ç”¨äº†å¤šä¸ªæ•°æ®ç»“æ„ç»„åˆè¡¨ç¤ºå“ˆå¸Œè¡¨ï¼Œå…¶ä¸­ [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) æ˜¯æœ€æ ¸å¿ƒçš„ç»“æ„ä½“ï¼Œæˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹è¯¥ç»“æ„ä½“çš„å†…éƒ¨å­—æ®µï¼š

```go
// src/runtime/map.go
type hmap struct {
    count     int    // å…ƒç´ ä¸ªæ•°ï¼Œè°ƒç”¨ len(map) æ—¶ï¼Œç›´æ¥è¿”å›æ­¤å€¼
    flags     uint8  // å¹¶å‘è¯»å†™çš„çŠ¶æ€æ ‡å¿—ï¼Œå¦‚æœ =1 æ—¶è¯»å†™è¿™ä¸ª mapï¼Œä¼š panic
    B         uint8  // æ¡¶æ•°é‡çš„log2å¯¹æ•°ï¼ˆå› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ buckets æ•°ç»„çš„é•¿åº¦æ˜¯ 2^B
    noverflow uint16 // æº¢å‡ºçš„ bucket ä¸ªæ•°
    hash0     uint32 // å“ˆå¸Œç§å­ï¼Œä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ã€‚åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥

    buckets    unsafe.Pointer // æŒ‡å‘æ¡¶æ•°ç»„ï¼Œå¤§å°ä¸º 2^B
    oldbuckets unsafe.Pointer // æ—§æ¡¶çš„åœ°å€ï¼Œç”¨äºæ‰©å®¹æ—¶ä¿å­˜æ‰©å®¹å‰çš„æ•°æ®
    nevacuate  uintptr        // æŒ‡ç¤ºæ‰©å®¹è¿›åº¦ï¼Œå°äºæ­¤åœ°å€çš„ buckets è¿ç§»å®Œæˆ
    extra *mapextra     // map é‡Œä¸å«æŒ‡é’ˆæ—¶ï¼Œç”¨è¿™ä¸ªå­˜ buckets å’Œ oldbuckets çš„æº¢å‡ºåŒºã€‚è¿™æ · GC æ—¶åªæ‰«æè¿™é‡Œå°±å¯ä»¥çŸ¥é“å“ªäº›æº¢å‡ºæ¡¶è¿˜åœ¨ä½¿ç”¨ï¼Œéœ€è¦ä¿ç•™ç©ºé—´ï¼Œè€Œä¸ç”¨æ‰«ææ•´ä¸ªæ‰€æœ‰ bucketsï¼Œå‡å°‘GCè€—æ—¶
}

type mapextra struct {
    overflow    *[]*bmap
    oldoverflow *[]*bmap
    nextOverflow *bmap
}
```

`buckets` æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ˜¯ä¸€ä¸ª `bmap` æ•°ç»„ã€‚ä¸‹æ–‡å°† `bmap` ç§°ä¸º **æ¡¶**ã€‚æ¯ä¸ªæ¡¶é‡Œæœ‰ `8` ä¸ªä½ç½®å¯ä»¥æ”¾ `key` å’Œ `value`ï¼Œä¸‹æ–‡ç§°è¿™ 8 ä¸ªä½ç½®ä¸º **æ ¼å­**.

è¿™ä¸ªç»“æ„æœ‰ç‚¹åƒç«è½¦ï¼Œæ¯ä¸ª `map` é‡Œæœ‰ `2^B` è¾†ç«è½¦ `buckets`ï¼Œæ¯æ¡ç«è½¦ç”±ä¸€å †è½¦å¢ `bmap` ä¸²è”ã€‚æ¯ä¸ªè½¦å¢é‡Œ `8` ä¸ªåº§ä½ã€‚



æºç é‡Œçš„ bmap ç»“æ„åªæœ‰ä¸€è¡Œï¼š

```golang
// runtime/map.go
// æºç é‡Œçš„ bmap ç»“æ„åªæœ‰ä¸€è¡Œï¼š
type bmap struct {
	tophash [bucketCnt]uint8
}
```

ç¼–è¯‘æ—¶ä¼šæ ¹æ® `map` çš„å…ƒç´ ç±»å‹æ¨å¯¼ï¼Œè¿™æ˜¯å®é™…ç¼–è¯‘ä»¥åçš„ç»“æ„ï¼š

```go
// cmd/compile/internal/gc.bmap
type bmap struct {
    topbits  [8]uint8     // hashå€¼çš„é«˜8ä½ï¼Œç”¨äºæ’åº
    keys     [8]keytype   // 8ä¸ªkey
    values   [8]valuetype // 8ä¸ªvalue
    pad      uintptr
    overflow uintptr      // æº¢å‡ºæ¡¶ã€‚å¦‚æœbmapé‡Œçš„å…ƒç´ è¶…è¿‡8ä¸ªï¼Œé‚£å°±éœ€è¦å†æ„å»ºä¸€ä¸ªbmapï¼Œè¿™ä¸ªå­—æ®µä¼šæŒ‡å‘è¿™ä¸ªæ–°bmapï¼Œç›¸å½“äºå¤šä¸ªbmapç”¨é“¾è¡¨ä¸²èµ·æ¥
}

// ç¼–è¯‘æœŸé—´æ„å»º map çš„å‡½æ•°
// cmd/compile/internal/gc.bmap
func bmap(t *types.Type) *types.Type {
    //(BUCKETSIZE = 8)
    arr = types.NewArray(keytype, BUCKETSIZE) // æ ¹æ®keyç±»å‹æ–°å»º keyæ•°ç»„
    keys := makefield("keys", arr)
	  field = append(field, keys)
  
    arr = types.NewArray(elemtype, BUCKETSIZE) // æ ¹æ®valueç±»å‹æ–°å»º valueæ•°ç»„
    ...
}
```

`bmap` å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„æ¡¶ï¼Œæ¡¶é‡Œé¢ä¼šæœ€å¤šè£… `8` ä¸ª `key`ã€‚åœ¨æ¡¶å†…ï¼Œåˆä¼šæ ¹æ® `key` è®¡ç®—å‡ºæ¥çš„ `hash` å€¼çš„é«˜ `B` ä½æ¥æŸ¥æ‰¾ `key`ï¼Œè¿™é«˜ `B` ä½ç§°ä¸º `tophash`ã€‚

å¦‚æœæ¡¶é‡Œçš„å…ƒç´ è¦è¶…è¿‡ `8` ä¸ªäº†ï¼Œè¿™æ—¶å€™éœ€è¦åœ¨æ¡¶åé¢æŒ‚ä¸Š **æº¢å‡ºæ¡¶**  `overflow bucket`ã€‚æº¢å‡ºæ¡¶æ˜¯åœ¨ Go è¯­è¨€è¿˜ä½¿ç”¨ C è¯­è¨€å®ç°æ—¶ä½¿ç”¨çš„è®¾è®¡ï¼Œç”±äºå®ƒèƒ½å¤Ÿå‡å°‘æ‰©å®¹çš„é¢‘ç‡æ‰€ä»¥ä¸€ç›´ä½¿ç”¨è‡³ä»Šã€‚ä½†ä¸€èˆ¬æ¥è¯´ä¸€ä¸ª `map` ä¸­ä¸ä¼šæœ‰å¤ªå¤šæº¢å‡ºæ¡¶ï¼Œå› ä¸ºæ¡¶ä¸­å…ƒç´ è¶…è¿‡8ä¸ªæ‰æŒ‚æº¢å‡ºæ¡¶ï¼Œè€Œ Go çš„è®¾è®¡é‡Œå¹³å‡è¶…è¿‡ 6.5 ä¸ªæ—¶å°±ä¼šè§¦å‘æ‰©å®¹ã€‚

æ³¨æ„åˆ° `key` å’Œ `value` æ˜¯å„è‡ªæ”¾åœ¨ä¸€èµ· `k/k/.../v/v/...` è¿™æ ·çš„å½¢å¼ï¼Œå¹¶ä¸æ˜¯ `k/v/k/v/...` è¿™æ ·çš„ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥é¿å…å†…å­˜å¯¹é½ï¼ŒèŠ‚çœç©ºé—´ã€‚

æ¯”å¦‚ `map[int64]int8` è¿™æ ·çš„ `map`ï¼Œå¦‚æœæŒ‰ç…§ `k/v/k/v/...` è¿™æ ·çš„æ¨¡å¼å­˜å‚¨ï¼Œé‚£åœ¨æ¯ä¸€ä¸ª `key/value` å¯¹ä¹‹åéƒ½è¦é¢å¤–å¯¹é½ 7 ä¸ªå­—èŠ‚ï¼›è€Œ `k/k/.../v/v/...` è¿™ç§å½¢å¼åˆ™åªéœ€è¦åœ¨æœ€åæ·»åŠ å¯¹é½ç©ºæ ¼ã€‚

![img](assets/v2-0178a76f87bb68fd7a645e6885e17525_b.jpg)



## åˆå§‹åŒ–

ä½¿ç”¨ `make` åˆ›å»ºå“ˆå¸Œï¼ŒGo è¯­è¨€ç¼–è¯‘å™¨éƒ½ä¼šåœ¨[ç±»å‹æ£€æŸ¥](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/)æœŸé—´å°†å®ƒä»¬è½¬æ¢æˆ [`runtime.makemap`](https://draveness.me/golang/tree/runtime.makemap)ã€‚è¿™ä¸ªå‡½æ•°ä¼šæŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤æ‰§è¡Œï¼š

1. è®¡ç®—å“ˆå¸Œå ç”¨çš„å†…å­˜æ˜¯å¦æº¢å‡ºæˆ–è€…è¶…å‡ºèƒ½åˆ†é…çš„æœ€å¤§å€¼ï¼›
2. è°ƒç”¨ [`runtime.fastrand`](https://draveness.me/golang/tree/runtime.fastrand) è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ï¼›
3. æ ¹æ®ä¼ å…¥çš„ `hint` è®¡ç®—å‡ºéœ€è¦çš„æœ€å°éœ€è¦çš„æ¡¶çš„æ•°é‡ï¼›
4. ä½¿ç”¨ [`runtime.makeBucketArray`](https://draveness.me/golang/tree/runtime.makeBucketArray) åˆ›å»ºç”¨äºä¿å­˜æ¡¶çš„æ•°ç»„ï¼›



# è®¿é—®

åœ¨ç¼–è¯‘çš„[ç±»å‹æ£€æŸ¥](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/)æœŸé—´ï¼Œ`hash[key]` ä»¥åŠç±»ä¼¼çš„æ“ä½œéƒ½ä¼šè¢«è½¬æ¢æˆå“ˆå¸Œçš„ `OINDEXMAP` æ“ä½œï¼Œ[ä¸­é—´ä»£ç ç”Ÿæˆ](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/)é˜¶æ®µä¼šåœ¨ [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) å‡½æ•°ä¸­å°†è¿™äº› `OINDEXMAP` æ“ä½œæ ¹æ®ä¸€ä¸ªè¿˜æ˜¯ä¸¤ä¸ªæ¥æ”¶å‚æ•°è½¬æ¢æˆ `mapaccess1` æˆ– `mapaccess2` å‡½æ•°ï¼š

```go
v     := hash[key] // => v     := *mapaccess1(maptype, hash, &key)
v, ok := hash[key] // => v, ok := mapaccess2(maptype, hash, &key)
```

[`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ [`runtime.bucketMask`](https://draveness.me/golang/tree/runtime.bucketMask) å’Œ [`runtime.add`](https://draveness.me/golang/tree/runtime.add) å¯¹å“ˆå¸Œçš„ä½Bä½è¿›è¡Œä¸æ“ä½œï¼Œæ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·ã€‚

å¦‚æœé‡åˆ° `map` æ­£åœ¨æ‰©å®¹çš„æƒ…å†µï¼Œé‚£æŸ¥åˆ°çš„æ¡¶éœ€è¦å¯èƒ½æ˜¯æ—§æ¡¶ï¼Œåˆ™å»æ—§æ¡¶é‡ŒæŸ¥æ‰¾ã€‚

æ‰¾åˆ°æ¡¶åï¼Œå†å– `hashcode` çš„é«˜8ä½ï¼ˆ`tophash`ï¼‰ï¼Œéå†æ¡¶ä¸­çš„å…ƒç´ ï¼Œé€ä¸ªæ¯”è¾ƒ `tophash`ã€‚å¦‚æœ `tophash` ç›¸åŒï¼Œå†æ¯”è¾ƒ `key` çš„å­—é¢å€¼


```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
    // è®¡ç®—å“ˆå¸Œ
  	hash := t.hasher(key, uintptr(h.hash0)) // hash0 æ˜¯æ–°å»º map æ—¶ fastrand å¾—åˆ°çš„å“ˆå¸Œç§å­
  
    m := bucketMask(h.B) // ä½Bä½é®ç½©
	  b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize))) // hash&m ä½œä¸ºæ¡¶ä¸‹æ ‡ã€‚æ ¹æ®ä¸‹æ ‡ç›´æ¥å®šä½æ¡¶
    
	  // è®¡ç®—å‡ºå“ˆå¸Œé«˜8ä½ï¼Œç”¨äºå¿«é€Ÿæ¯”å¯¹key
	  top := tophash(hash)
    
    // å¦‚æœæ­£åœ¨æ¬è¿ï¼ŒæŸ¥åˆ°çš„keyåœ¨æ—§æ¡¶é‡Œï¼Œåˆ™ä»æ—§æ¡¶éå†
    if c := h.oldbuckets; c != nil {
        //...
        b = oldb
    }
	
  
bucketloop:
    // ä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶
  	for ; b != nil; b = b.overflow(t) {
      ã€€// éå†æ¡¶ä¸­çš„ 8 ä¸ªä½ç½®
        for i := uintptr(0); i < bucketCnt; i++ {
	          // tophash ä¸åŒ¹é…ï¼Œç»§ç»­
	          if b.tophash[i] != top {
	              continue
	          }
	          // tophash åŒ¹é…ï¼Œå®šä½åˆ° key çš„ä½ç½®
	          k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
	           
	          // è¿›ä¸€æ­¥æ¯”è¾ƒ key åŸå€¼
	          if alg.equal(key, k) {
	              // å®šä½åˆ° value çš„ä½ç½®
	              v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
	              return v
	          }
	      }
	
	      // bucket æ‰¾å®Œï¼ˆè¿˜æ²¡æ‰¾åˆ°ï¼‰ï¼Œç»§ç»­åˆ° overflow bucket é‡Œæ‰¾
	      b = b.overflow(t)
	      // overflow bucket ä¹Ÿæ‰¾å®Œäº†ï¼Œè¯´æ˜æ²¡æœ‰ç›®æ ‡ key
	      // è¿”å›é›¶å€¼
	      if b == nil {
	          return unsafe.Pointer(&zeroVal[0])
	      }
    }
}
```

ä¾‹å¦‚ï¼Œç°åœ¨æœ‰ä¸€ä¸ª `key `ç»è¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—åï¼Œå¾—åˆ°çš„å“ˆå¸Œç»“æœæ˜¯ï¼š

```shell
hashé«˜8ä½   hash                                                  hashä½5ä½
10010111     | 000011110110110010001111001010100010010110010101010 â”‚ 00110
```

ç”¨æœ€åçš„ `5` ä¸ª `bit` ä½ `00110` ä½œä¸ºæ¡¶ä¸‹æ ‡ï¼Œä¹Ÿå°±æ˜¯10è¿›åˆ¶ä¸‹çš„ `6` å·æ¡¶ã€‚

å†ç”¨å“ˆå¸Œå€¼çš„é«˜ `8` ä½ï¼Œå¿«é€Ÿæ¯”è¾ƒæ¡¶å†…å„æ ¼å­çš„ `tophash`ã€‚å¦‚æœæ‰¾åˆ°ä¸€æ ·çš„ï¼Œå†è¿›ä¸€æ­¥æ¯”è¾ƒ `key` çš„åŸå€¼ã€‚

å¦‚æœåœ¨æ¡¶ä¸­æ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸” `overflow` ä¸ä¸ºç©ºï¼Œåˆ™å¾ªç¯ç»§ç»­å»æ¡¶é“¾è¡¨é‡Œçš„ä¸‹ä¸€ä¸ªï¼Œå³æº¢å‡ºæ¡¶ä¸­å¯»æ‰¾ã€‚

> ä¸ºä»€ä¹ˆæ˜¯ `2^B` ä¸ªæ¡¶ï¼Ÿ
>
> è¿™æ ·å–ä½ `B` ä½å¯ä»¥ç›´æ¥é€šè¿‡ä¸æ“ä½œå¾—åˆ°æ¡¶ä¸‹æ ‡ï¼Œè®¡ç®—ç®€å•å¿«é€Ÿï¼Œä¸ç”¨å–æ¨¡ï¼›æ‰©å®¹æ¬è¿æ—¶ä¹Ÿåªéœ€æ ¹æ®æ‰©å®¹å¤šå‡ºæ¥çš„äºŒè¿›åˆ¶ä½ï¼Œå°†åŸæ¡¶å…ƒç´ åˆ†æµåˆ°ä¸¤ä¸ªï¼Œè¯¦è§åé¢ã€‚



å¦å¤–ï¼Œæ ¹æ® `key` çš„ä¸åŒç±»å‹ï¼Œç¼–è¯‘å™¨è¿˜ä¼šå°†æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„å‡½æ•°ç”¨æ›´å…·ä½“çš„å‡½æ•°æ›¿æ¢ï¼Œä»¥ä¼˜åŒ–æ•ˆç‡ã€‚ç”±äºæå‰çŸ¥æ™“äº† `key` çš„ç±»å‹ï¼Œæ‰€ä»¥å†…å­˜å¸ƒå±€æ˜¯å¾ˆæ¸…æ¥šçš„ï¼Œèƒ½èŠ‚çœå¾ˆå¤šæ“ä½œï¼Œæé«˜æ•ˆç‡ã€‚

```go
// src/runtime/hashmap_fast.go
keyçš„ç±»å‹  å‡½æ•°
uint32	   mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer
uint64	   mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer
string	   mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer
```




# æ‰©å®¹

### æ—¶æœº

å¯ä»¥çœ‹åˆ°ï¼Œä¸€ä¸ªæ¡¶åé¢å¯èƒ½ä¸²äº†å¥½å‡ ä¸ªæº¢å‡ºæ¡¶ã€‚æŸ¥æ‰¾æ—¶éœ€è¦å…ˆå®šä½æ¡¶ï¼Œå†éå†æº¢å‡ºæ¡¶ã€‚å¦‚æœæº¢å‡ºæ¡¶è¿‡å¤šï¼Œä¼šå¯¼è‡´æŸ¥è¯¢æ€§èƒ½ä¸‹é™ã€‚å› æ­¤ï¼Œéœ€è¦æœ‰ä¸€ä¸ªæŒ‡æ ‡æ¥è¡¡é‡å‰é¢æè¿°çš„æƒ…å†µï¼Œè¿™å°±æ˜¯**è´Ÿè½½å› å­**ã€‚`Go` é‡Œçš„ **è´Ÿè½½å› å­** = **å…ƒç´ ä¸ªæ•° / æ¡¶æ•°**

```go
loadFactor := count / (2^B)
```

æ‰©å®¹çš„æ—¶æœºï¼šåœ¨å‘ `map` æ’å…¥æ–° `key` åï¼Œä¼šè¿›è¡Œæ¡ä»¶æ£€æµ‹ï¼Œç¬¦åˆä¸‹é¢è¿™ 2 ä¸ªæ¡ä»¶ï¼Œå°±ä¼šè§¦å‘æ‰©å®¹ï¼š

1. è£…è½½å› å­è¶…è¿‡é˜ˆå€¼ï¼Œæºç é‡Œå®šä¹‰çš„é˜ˆå€¼æ˜¯ `6.5`ã€‚
2. æº¢å‡ºçš„æ¡¶æ•°é‡è¿‡å¤šï¼Œè¶…è¿‡æ­£å¸¸æ¡¶æ•°é‡æˆ– `2^15` ä¸ªï¼ˆæ’å…¥å¾ˆå¤šå…ƒç´ ã€å†åˆ é™¤æ—¶ï¼Œå¯èƒ½å¯¼è‡´æº¢å‡ºæ¡¶å¾ˆå¤šï¼Œå³ç¨€ç–ã€‚å› ä¸ºåˆ é™¤å…ƒç´ æ—¶ä¸ä¼šåˆ æ¡¶ï¼‰
   1. `B < 15 && noverflow >= 2^B`
   2. `B >= 15 && noverflow >= 2^15`

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
    if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
        hashGrow(t, h)
        goto again // Growing the table invalidates everything, so try again
    }
}
```

è¿™ä¸¤ç§æ¡ä»¶ä¸‹éƒ½ä¼šå‘ç”Ÿæ‰©å®¹ã€‚ä½†æ˜¯æ‰©å®¹çš„ç­–ç•¥å¹¶ä¸ç›¸åŒï¼Œæ¯•ç«Ÿä¸¤ç§æ¡ä»¶åº”å¯¹çš„åœºæ™¯ä¸åŒã€‚

1. å¯¹äºæ¡ä»¶1ï¼Œå…ƒç´ å¤ªå¤šï¼Œè€Œæ¡¶æ•°é‡å¤ªå°‘ï¼Œå¾ˆç®€å•ï¼šå°† `B` åŠ  `1`ï¼Œæ–°ç”³è¯·ä¸€ä¸ª `2^(B+1)` çš„æ¡¶æ•°ç»„ï¼Œæ¡¶æ•°é‡ç›´æ¥å˜æˆåŸæ¥çš„ `2` å€ã€‚è¿™ç§æ‰©å®¹å« **å¢é‡æ‰©å®¹**ã€‚

2. å¯¹äºæ¡ä»¶2ï¼Œå…¶å®å…ƒç´ æ²¡é‚£ä¹ˆå¤šï¼Œä½†æ˜¯æº¢å‡ºæ¡¶æ•°é‡ç‰¹åˆ«å¤šï¼Œè¯´æ˜å¾ˆå¤šæ¡¶éƒ½æ²¡è£…æ»¡ã€‚è§£å†³åŠæ³•å°±æ˜¯æ–°å»ºä¸€ä¸ªç›¸åŒå¤§å°çš„æ–°æ¡¶æ•°ç»„ï¼Œå°†è€æ¡¶æ•°ç»„ä¸­çš„å…ƒç´ ç§»åŠ¨åˆ°æ–° æ¡¶æ•°ç»„ï¼Œä½¿å¾—åŒä¸€ä¸ªæ¡¶ä¸­çš„ `key` æ’åˆ—åœ°æ›´ç´§å¯†ã€‚è¿™ç§å« **ç­‰é‡æ‰©å®¹**ã€‚ä¸¥æ ¼ä¸Šè¯´å…¶å®ä¸ç®—æ‰©å®¹ï¼Œç®—æ•´ç†ç¢ç‰‡ã€‚

ç”±äºæ‰©å®¹éœ€è¦å°†åŸæœ‰çš„ `key/value` é‡æ–°æ¬è¿åˆ°æ–°çš„å†…å­˜åœ°å€ï¼Œå¦‚æœæœ‰å¤§é‡çš„ `key/value` éœ€è¦æ¬è¿ï¼Œä¼šéå¸¸å½±å“æ€§èƒ½ã€‚å› æ­¤ `Go map` çš„æ‰©å®¹é‡‡å–äº† **æ¸è¿›å¼æ‰©å®¹** çš„æ–¹å¼ï¼Œç±»ä¼¼ `redis` çš„æ‰©å®¹ï¼ŒåŸæœ‰çš„ `key` å¹¶ä¸ä¼šä¸€æ¬¡æ€§æ¬è¿å®Œæ¯•ã€‚

> ä¸ºå•¥è´Ÿè½½å› å­æ˜¯ 6.5 ?
>
> å¤ªå°ä¼šå¯¼è‡´ææ˜“è§¦å‘æ‰©å®¹ï¼Œé€ æˆç©ºé—´æµªè´¹ï¼›å¤ªå¤šä¼šå¯¼è‡´æä¸æ˜“è§¦å‘æ‰©å®¹ï¼Œé€ æˆ `overflow` è¿‡å¤šã€‚
>
> ä½œè€…æµ‹è¯•äº†å„è´Ÿè½½å› å­ä¸‹çš„å¹³å‡ `overflow` æ•°ã€å‘½ä¸­ç‡ã€`miss` ç‡ç­‰æŒ‡æ ‡ï¼Œæœ€ç»ˆå–äº†ä¸€ä¸ªä¸­é—´æ•° 6.5ã€‚



### æ‰©å®¹è¿‡ç¨‹

æ‰©å®¹å…¶å®åˆ†ä¸ºä¸¤æ­¥ï¼š`hashGrow()` æ‰©å®¹ å’Œ `growWork()` æ¬è¿ã€‚

 `hashGrow()` å‡½æ•°å®é™…ä¸Šå¹¶æ²¡æœ‰çœŸæ­£åœ°æ¬è¿ï¼Œå®ƒåªæ˜¯åˆ†é…å¥½äº†æ–°çš„ `buckets`ï¼Œå¹¶å°†è€çš„ `buckets` æŒ‚åˆ°äº† `oldbuckets` å­—æ®µä¸Šã€‚

```go
func hashGrow(t *maptype, h *hmap) {
    bigger := uint8(1)
    if !overLoadFactor(h.count+1, h.B) {  // å¦‚æœæ˜¯ç­‰é‡æ‰©å®¹ï¼Œè®¾ç½®æ ‡è®°
        bigger = 0
        h.flags |= sameSizeGrow
    }
        
    oldbuckets := h.buckets                           // å°†bucketsèµ‹å€¼ç»™oldbuckets
    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) // ç”³è¯·æ–°æ¡¶
  
    // æ›´æ–°hmapçš„å˜é‡
    h.B += bigger             // æ›´æ–° B           
    h.flags = flags
    h.oldbuckets = oldbuckets // å°†æ—§æ¡¶èµ‹å€¼ç»™oldbuckets
    h.buckets = newbuckets
    h.nevacuate = 0
    h.noverflow = 0
  
    h.extra.oldoverflow = h.extra.overflow
  	h.extra.overflow = nil
  	h.extra.nextOverflow = nextOverflow
}
```





### æ¬è¿è¿‡ç¨‹

æ¬è¿çš„åŠ¨ä½œåœ¨ `growWork()` å‡½æ•°ä¸­ï¼Œè€Œè°ƒç”¨ `growWork()` å‡½æ•°çš„åŠ¨ä½œæ˜¯åœ¨ `mapassign` å’Œ `mapdelete` å‡½æ•°ä¸­ã€‚

ä¹Ÿå°±æ˜¯æ’å…¥æˆ–ä¿®æ”¹ã€åˆ é™¤ `key` çš„æ—¶å€™ï¼Œéƒ½ä¼šå°è¯•è¿›è¡Œæ¬è¿ `buckets` çš„å·¥ä½œã€‚å…ˆæ£€æŸ¥ `key` æ‰€åœ¨çš„ `oldbuckets` æ˜¯å¦æ¬è¿å®Œæ¯•ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™å…ˆå¯¹å…¶è¿›è¡Œæ¬è¿ã€‚ç„¶åå†æ£€æŸ¥å…¶ä»–æ¬è¿çŠ¶æ€è¿‡ç¨‹ä¸­çš„æ¡¶ï¼Œå¦‚æœæœ‰ï¼ŒååŠ©è¿›è¡Œæ¬è¿ã€‚

```go
func growWork(t *maptype, h *hmap, bucket uintptr) {
    evacuate(t, h, bucket&h.oldbucketmask()) // æ¬è¿æ—§æ¡¶ï¼Œè¿™æ · assign å’Œ delete éƒ½ç›´æ¥åœ¨æ–°æ¡¶é›†åˆä¸­è¿›è¡Œ
    if h.growing() {
        evacuate(t, h, h.nevacuate)          // å†ååŠ©æ¬è¿ä¸€æ¬¡å…¶ä»–æ¡¶
    }
}
```



æ¬è¿çš„å…³é”®å‡½æ•°æ˜¯ `evacuate`ï¼š

è¿™é‡Œé¢æ¯”è¾ƒä¸»è¦çš„é€»è¾‘æ˜¯å¢é‡æ‰©å®¹æ—¶çš„åˆ†æµï¼Œæ¯”å¦‚åŸæ¥æ¡¶ä¸­8ä¸ªkvï¼Œå¢é‡æ‰©å®¹ååˆ†åˆ°2ä¸ªæ–°æ¡¶ä¸­ï¼Œé‚£ä¹ˆè¦è§£å†³2ä¸ªé—®é¢˜ï¼š1. å¦‚ä½•å®šä½æ–°æ¡¶ä½ç½®ï¼Œ2. å¦‚ä½•å°†åŸæ¡¶é‡Œçš„kvåˆ†æµåˆ°2ä¸ªæ–°æ¡¶ä¸­ã€‚

å¦‚ä½•å®šä½æ–°æ¡¶ï¼šæ¯”å¦‚åŸæ¥æœ‰4ä¸ªæ¡¶ï¼Œæ‰©å®¹åå˜ä¸º8ä¸ªæ¡¶ï¼ŒåŸæ¥çš„1å·æ¡¶å˜ä¸ºæ–°çš„1å·å’Œ5å·æ¡¶ã€‚è¿™ä¸ª5å·åœ°å€æ€ä¹ˆå¾—å‘¢ï¼Œç”¨åŸæ¥çš„1å· + (æ—§æ¡¶å¤§å°) å°±å¯å¾—åˆ°

ç„¶åæ˜¯æ¡¶å…ƒç´ å¦‚ä½•æ‘Šåˆ°æ–°çš„2ä¸ªæ¡¶é‡Œï¼šè¿™é‡Œä½¿ç”¨ `2^B` ä½œä¸ºæ©ç ï¼Œå’Œ `hashcode` è¿›è¡Œä¸æ“ä½œï¼Œæ ¹æ®ä¸ç»“æœæ˜¯å¦ä¸º 0 åˆ¤æ–­è½å…¥1è¿˜æ˜¯5å·æ¡¶é‡Œã€‚

```golang
// runtime/map.go
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // å®šä½è€çš„ bucket åœ°å€
    newbit := h.noldbuckets()                                        // ç»“æœæ˜¯ 2^Bï¼Œå¦‚ B = 5ï¼Œç»“æœä¸º32
    
    if !evacuated(b) {            // å¦‚æœ b æ²¡æœ‰è¢«æ¬è¿è¿‡
    
        // å£°æ˜2ä¸ªå˜é‡ xyï¼Œå­˜å‚¨ç›®æ ‡æ¬è¿åœ°å€ï¼Œç­‰é‡æ‰©å®¹ç”¨, å¢é‡æ‰©å®¹ç”¨ y
        var xy [2]evacDst
    
        // é»˜è®¤æ˜¯ç­‰é‡æ‰©å®¹ï¼Œå‰å bucket åºå·ä¸å˜ï¼Œä½¿ç”¨ x æ¥è¿›è¡Œæ¬è¿
        x := &xy[0]
        x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
        x.k = add(unsafe.Pointer(x.b), dataOffset)
        x.v = add(x.k, bucketCnt*uintptr(t.keysize))

        // å¢é‡æ‰©å®¹ï¼Œå‰å bucket åºå·æœ‰å˜ï¼Œåˆ™å¢åŠ ä¸€ä¸ª y æ¥è¿›è¡Œåˆ†æµã€‚å³è¢«æ¬è¿çš„å…ƒç´ å¯èƒ½æ¬åˆ° xï¼Œä¹Ÿå¯èƒ½æ¬åˆ° yï¼Œæ ¹æ® hash & 2^B æ˜¯å¦ä¸º0å†³å®šæ¬åˆ° x è¿˜æ˜¯ y
        if !h.sameSizeGrow() { 
              y := &xy[1]
              y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
              y.k = add(unsafe.Pointer(y.b), dataOffset)
              y.v = add(y.k, bucketCnt*uintptr(t.keysize))
        }

        // è¿ç§»è€çš„ b åŠå…¶ overflow é“¾è¡¨
        for ; b != nil; b = b.overflow(t) {
            k := add(unsafe.Pointer(b), dataOffset)
            v := add(k, bucketCnt*uintptr(t.keysize))

            // éå† bucket ä¸­çš„æ‰€æœ‰ cell
            for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
                top := b.tophash[i]
                //...
                k2 := k // å¦‚æœ key æ˜¯æŒ‡é’ˆï¼Œåˆ™è§£å¼•ç”¨
                //...

                var useY uint8 // é»˜è®¤ä½¿ç”¨ Xï¼Œç­‰é‡æ‰©å®¹                                   
                if !h.sameSizeGrow() {                             // å¦‚æœä¸æ˜¯ç­‰é‡æ‰©å®¹
                    hash := t.hasher(k2, uintptr(h.hash0))           // rehash
                    //...
                    if hash&newbit != 0 {
                        useY = 1
                    }
                    //...
                    dst := &xy[useY] // ç›®æ ‡æ¬è¿åœ°å€
                    
                    // å¦‚æœç›®æ ‡æ¬è¿åœ°å€å·²ç»æœ‰8ä¸ªkväº†ï¼Œæ–°å»ºä¸€ä¸ªæº¢å‡ºæ¡¶
                    if dst.i == bucketCnt {
                        dst.b = h.newoverflow(t, dst.b)
                        dst.i = 0
                        dst.k = add(unsafe.Pointer(dst.b), dataOffset)
                        dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
                    }
                    //...
                    typedmemmove(t.key, dst.k, k)  // ä» k æ‹·è´è‡³ dst.k
                    typedmemmove(t.elem, dst.v, v)
                    dst.i++                        // kvè®¡æ•°å™¨
                    dst.k = add(dst.k, uintptr(t.keysize))   // ä¿®æ”¹ k çš„æœ€æ–°åœ°å€
                    dst.v = add(dst.v, uintptr(t.valuesize))
                }
            }            
        }
    }
    // æ¬è¿å®Œæˆï¼Œæ›´æ–°æ¬è¿è¿›åº¦è®¡æ•°å™¨ã€‚å¹¶åœ¨æ‰€æœ‰çš„æ—§æ¡¶éƒ½è¢«åˆ†æµåæ¸…ç©º oldbuckets å’Œ oldoverflow
    if oldbucket == h.nevacuate {
        advanceEvacuationMark(h, t, newbit)
    }
}
```

æ¬è¿æœŸé—´ï¼Œå¦‚æœæŸ¥è¯¢æ—¶å‘ç° `key` è½å…¥æ—§æ¡¶ï¼Œåˆ™ä¼šä»æ—§æ¡¶ä¸­æŸ¥æ‰¾ã€‚



## éå†

ç†è§£äº†ä¸Šé¢æ¡¶åºå·çš„å˜åŒ–ï¼Œæˆ‘ä»¬å°±å¯ä»¥å›ç­”å¦ä¸€ä¸ªé—®é¢˜äº†ï¼šä¸ºä»€ä¹ˆéå† `map` æ˜¯æ— åºçš„ï¼Ÿ

1. `map` æ ¹æœ¬å°±æ²¡æœ‰ç»´æŠ¤ `key` çš„é¡ºåºï¼Œè®¡ç®— `key` çš„æ¡¶æ—¶æ˜¯ç”¨ `hash` ä½ `B` ä½ç®—çš„ï¼Œæœ¬æ¥æœ‰åºçš„ `key`ï¼Œ`hash` åå°±æ— åºäº†ã€‚
2. `map` åœ¨æ‰©å®¹åï¼Œä¼šå‘ç”Ÿ `key` çš„æ¬è¿ã€‚æœ‰çš„ `key` åœ¨æ—§æ¡¶é‡Œï¼Œæœ‰çš„åœ¨æ–°æ¡¶é‡Œã€‚å¹¶ä¸”æœ‰çš„ `key` æ¡¶åºå·ä¹Ÿä¼šå˜ï¼Œä¼šåŠ ä¸Š `2^B`ã€‚å› æ­¤ï¼Œéå†ã€ä¿®æ”¹ `map`ã€å†éå†ï¼Œä¸¤æ¬¡å¾—åˆ°çš„éå†é¡ºåºå°±å¯èƒ½ä¸ä¸€æ ·äº†ã€‚

å½“ç„¶ï¼Œ`Go` åšå¾—æ›´ç»ï¼Œéå† `map` æ—¶ï¼Œå¹¶ä¸æ˜¯å›ºå®šåœ°ä» `0` å·æ¡¶å¼€å§‹éå†ï¼Œè€Œæ˜¯é€šè¿‡ `fastrand` ç®—äº†ä¸ªéšæœºæ•°ï¼Œä»ä¸€ä¸ªéšæœºæ¡¶å¼€å§‹ï¼Œå¹¶ä¸”æ˜¯ä»è¿™ä¸ªæ¡¶å†…çš„éšæœºæ ¼å­å¼€å§‹éå†ã€‚ç‰¹æ„è®¾è®¡æˆäº†æ— åºè¿­ä»£çš„ç»“æœï¼Œä»¥é¿å…ç¨‹åºå‘˜ä¾èµ– `map` æœ‰åºéå†çš„ç»“æœã€‚





# å†™

å¯¹ `key` è®¡ç®— `hash` å€¼ï¼Œæ ¹æ® `hash` å€¼æŒ‰ç…§ä¹‹å‰çš„æµç¨‹ï¼Œæ‰¾åˆ°è¦èµ‹å€¼çš„ä½ç½®ã€‚æºç å¤§ä½“å’ŒæŸ¥æ‰¾çš„ç±»ä¼¼ã€‚æ ¸å¿ƒè¿˜æ˜¯ä¸€ä¸ªåŒå±‚å¾ªç¯ï¼Œå¤–å±‚éå† `bucket` å’Œå®ƒçš„ `overflow bucket`ï¼Œå†…å±‚éå†æ•´ä¸ª `bucket` çš„å„ä¸ª `cell`ã€‚å¦‚æœ `key` ä¸Šæœ‰å€¼ï¼Œå°±æ‰§è¡Œ `update`ï¼Œå¦åˆ™æ‰§è¡Œ `insert`ã€‚

å‡½æ•°é¦–å…ˆä¼šæ£€æŸ¥ `map` çš„æ ‡å¿—ä½ `flags`ã€‚å¦‚æœ `flags` çš„å†™æ ‡å¿—ä½æ­¤æ—¶è¢«ç½® `1` äº†ï¼Œè¯´æ˜æœ‰å…¶ä»–åç¨‹åœ¨æ‰§è¡Œå†™æ“ä½œï¼Œè¿›è€Œå¯¼è‡´ç¨‹åº `panic`ã€‚è¿™ä¹Ÿè¯´æ˜äº† `map` å¯¹åç¨‹æ˜¯ä¸å®‰å…¨çš„ã€‚

å¦å¤–é€šè¿‡å‰æ–‡æˆ‘ä»¬çŸ¥é“æ‰©å®¹æ˜¯æ¸è¿›å¼çš„ï¼Œå¦‚æœ `map` å¤„åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œé‚£ä¹ˆè¿™æ¬¡ä¼šå…ˆååŠ©æ‰©å®¹ï¼Œå®Œäº†æ‰å‘æ–°æ¡¶é‡Œå†™æ•°æ®ã€‚

æ’å…¥å…ƒç´ åï¼Œä¼šè®¡ç®—è´Ÿè½½å› å­ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹ã€‚



# åˆ 

åœ¨ç¼–è¯‘æœŸé—´ï¼Œ`delete` å…³é”®å­—ä¼šè¢«è½¬æ¢æˆæ“ä½œä¸º `ODELETE` çš„èŠ‚ç‚¹ï¼Œè€Œ [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) ä¼šå°† `ODELETE` èŠ‚ç‚¹è½¬æ¢æˆ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete) å‡½æ•°ç°‡ä¸­çš„ä¸€ä¸ªï¼ŒåŒ…æ‹¬ [`runtime.mapdelete`](https://draveness.me/golang/tree/runtime.mapdelete)ã€`mapdelete_faststr`ã€`mapdelete_fast32` å’Œ `mapdelete_fast64`ã€‚

åˆ é™¤é€»è¾‘å’Œå†™ç±»ä¼¼ï¼Œåªä¸è¿‡åˆ é™¤é€»è¾‘æ˜¯æŠŠå…ƒç´ ç½®ä¸º `nil`ã€‚å¹¶å°† `tophash` ç½®ä¸º **å·²åˆ é™¤** çŠ¶æ€ã€‚

```go
// æ¸…ç©º key
if t.indirectkey() {
    *(*unsafe.Pointer)(k) = nil
} else if t.key.ptrdata != 0 {
    memclrHasPointers(k, t.key.size)
}

// æ¸…ç©º value
e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
if t.indirectelem() {
    *(*unsafe.Pointer)(e) = nil
} else if t.elem.ptrdata != 0 {
    memclrHasPointers(e, t.elem.size)
} else {
    memclrNoHeapPointers(e, t.elem.size)
}

// ä¿®æ”¹ tophash
b.tophash[i] = emptyOne
```

åˆ é™¤å¹¶ä¸ä¼šé‡Šæ”¾ `cell`ï¼Œåªæ˜¯å°† `cell` çš„ `tophash` æ ‡è®°ä¸ºäº† `emptyOne` çŠ¶æ€ã€‚

åç»­å†™å…¥æ–°å…ƒç´ æ—¶ï¼Œå¯ä»¥å¤ç”¨ `emptyOne` çŠ¶æ€çš„ `cell` ã€‚

```go
// åˆ¤æ–­cellæ˜¯å¦å¯å†™å…¥ã€‚åˆ é™¤çŠ¶æ€çš„cellï¼Œå¯ä»¥å¤ç”¨
func isEmpty(x uint8) bool {
	return x <= emptyOne
}

// å†™map
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	for i := uintptr(0); i < bucketCnt; i++ {
		if isEmpty(b.tophash[i]) {
			if insertb == nil { // å†™åˆ°æ–°çš„ä½ç½®ï¼Œæˆ–è€…ä¹‹å‰å·²åˆ é™¤çš„cell
				insertb = b
				inserti = i
			}
        }
	}
}
```





# å’Œ redis å“ˆå¸Œè¡¨çš„å¼‚åŒ

##### æ•°æ®ç»“æ„

`redis` çš„ `kv` æ˜¯åŒ…è£…åœ¨ `dictEntry` ç»“æ„é‡Œçš„ï¼Œ`go` çš„ `kv` æ˜¯é•¿åº¦ä¸º 8 çš„ `kkkkkkkk/vvvvvvvv` æ•°ç»„ã€‚

##### å†²çªè§£å†³

å‡ä¸ºæ‹‰é“¾æ³•ã€‚ä½† `redis` æ¯ä¸ªæ¡¶æ²¡æœ‰æ ¼å­æ•°é™åˆ¶ï¼Œ `dictEntry` é€šè¿‡é“¾è¡¨ç›¸è¿ã€‚`go` é‡Œæ¯ä¸ªæ¡¶æœ‰å›ºå®šçš„ 8 ä¸ªæ ¼å­ï¼Œè¶…è¿‡åå­˜åˆ°æº¢å‡ºæ¡¶é‡Œã€‚

##### å“ˆå¸ŒæŸ¥æ‰¾

å‡ä¸ºæ ¹æ® `hash` æŸ¥æ¡¶ã€‚`go` é‡Œå¤šäº†ä¸ªé€šè¿‡ `tophash` å¿«é€Ÿè¯•é”™çš„ä¼˜åŒ–ã€‚

##### æ‰©å®¹æ—¶æœº

`redis`ï¼šæ¯ä¸ªæ¡¶å­˜å‚¨ >= 1 ä¸ª `key ` æ—¶æ‰©å®¹ã€‚<= 0.1 ä¸ª `key` æ—¶ç¼©å®¹ã€‚

`go`ï¼šæ¯ä¸ªæ¡¶å­˜å‚¨ >= 6.5 ä¸ª `key` æ—¶æ‰©å®¹ã€‚æº¢å‡ºæ¡¶ >= æ­£å¸¸æ¡¶æ•°é‡æ—¶ ç­‰é‡æ‰©å®¹ã€‚ä¸æ”¯æŒç¼©å®¹ã€‚æ’å…¥å…ƒç´ åæ£€æŸ¥ã€‚

##### æ¸è¿›å¼æ‰©å®¹

æ‰©å®¹æœŸé—´æŸ¥æ‰¾æ—¶å‡ä¸ºå…ˆæŸ¥æ‰¾è€æ¡¶ã€‚åˆ¤æ–­è€æ¡¶æ— æ•°æ®æ‰å»æ–°æ¡¶æ‰¾ã€‚

`redis`ï¼šå¢åˆ æ”¹æŸ¥æ—¶å‡ä¼šè§¦å‘ã€‚

`go`ï¼šä»…åœ¨å¢åˆ æ—¶è§¦å‘ã€‚





# æ€»ç»“

æ•°æ®ç»“æ„ï¼š`Go` è¯­è¨€ä¸­ï¼Œé€šè¿‡æ•°ç»„+é“¾è¡¨å®ç° `map`ï¼Œç”¨é“¾è¡¨æ³•è§£å†³å“ˆå¸Œå†²çªã€‚åˆ©ç”¨å°† 8ä¸ª `key` / 8ä¸ª`value` ä¾æ¬¡æ”¾ç½®çš„åšæ³•å‡å°‘äº†å¯¹é½æ‰€éœ€çš„ç©ºé—´ã€‚

æŸ¥æ‰¾ï¼šé€šè¿‡ `key` çš„å“ˆå¸Œå€¼å°† `key` æ•£è½åˆ°ä¸åŒçš„æ¡¶ä¸­ã€‚æ¯”å¦‚è¯´æœ‰ `2^5=32` ä¸ªæ¡¶ï¼Œå°±ç”¨å“ˆå¸Œå€¼çš„ä½ `5` ä½åˆ¤æ–­è½å…¥å“ªä¸ªæ¡¶ã€‚å†ç”¨å“ˆå¸Œå€¼çš„é«˜ `8` ä½å’Œ `key` å€¼æ¯”å¯¹æ¡¶ä¸­å…ƒç´ 

æ‰©å®¹ï¼šå½“å‘æ¡¶ä¸­æ·»åŠ äº†å¾ˆå¤š `key`ï¼Œé€ æˆå…ƒç´ è¿‡å¤šï¼ˆæ¯ä¸ªæ¡¶å†…çš„å…ƒç´ æ•°è¶…è¿‡ `6.5`ï¼‰ï¼Œæˆ–è€…æº¢å‡ºæ¡¶å¤ªå¤šï¼ˆè¶…è¿‡æ¡¶æ•°é‡æˆ– `2^15`ï¼‰ï¼Œå°±ä¼šè§¦å‘æ‰©å®¹ã€‚

- å¯¹å‰ä¸€ç§æƒ…å†µï¼ŒåŠ æ¡¶çš„ä¸ªæ•°å°±å¯ä»¥äº†ï¼Œå¯¹åº”çš„æ˜¯ `2` å€å®¹é‡çš„ **å¢é‡æ‰©å®¹**ï¼Œæ‰©å®¹æœŸé—´éœ€è¦ `rehash` é‡æ–°åˆ†æ¡¶ã€‚
- åè€…æ˜¯ç”±äºå¤§é‡å†™å…¥å’Œåˆ é™¤å…ƒç´ é€ æˆçš„æ•°æ®ç©ºæ´ï¼Œåªéœ€è¦é‡æ–°æ•´ç†ä¸‹æº¢å‡ºæ¡¶é‡Œçš„æ•°æ®å°±å¯ä»¥ï¼Œç§°ä¸º **ç­‰é‡æ‰©å®¹**ã€‚

æ‰©å®¹è¿‡ç¨‹æ˜¯æ¸è¿›çš„ï¼Œä¸»è¦æ˜¯é˜²æ­¢ä¸€æ¬¡æ‰©å®¹éœ€è¦æ¬è¿çš„ `key` æ•°é‡è¿‡å¤šï¼Œå¼•å‘æ€§èƒ½é—®é¢˜ã€‚è§¦å‘æ‰©å®¹çš„æ—¶æœºæ˜¯å¢åŠ äº†æ–°å…ƒç´ ï¼Œæ¬è¿çš„æ—¶æœºåˆ™å‘ç”Ÿåœ¨èµ‹å€¼/åˆ é™¤æœŸé—´ï¼Œæ¯æ¬¡æœ€å¤šæ¬è¿ä¸¤ä¸ª `bucket`ã€‚



#### é—®é¢˜

##### åˆ é™¤æ‰mapä¸­çš„å…ƒç´ æ˜¯å¦ä¼šé‡Šæ”¾å†…å­˜ï¼Ÿ

ä¸ä¼šï¼Œåˆ é™¤æ“ä½œä»…ä»…å°†å¯¹åº”çš„ `tophash[i]` è®¾ç½®ä¸º `empty`ï¼Œå¹¶éé‡Šæ”¾å†…å­˜ã€‚è‹¥è¦é‡Šæ”¾å†…å­˜åªèƒ½ç­‰å¾…æŒ‡é’ˆæ— å¼•ç”¨åè¢«ç³»ç»Ÿ `GC`



##### map çš„ iterator æ˜¯å¦å®‰å…¨ï¼Ÿ

`for k, v := range map` ä¼šå¤åˆ¶ `map` çš„ `key` å’Œ `value`ï¼Œè¿­ä»£æœŸé—´ä¿®æ”¹ `map` ä¸ä¼šå½±å“ `range` é‡Œçš„ `value`ï¼Œä½†ä¼šå½±å“ `map[k]` å¾—åˆ°çš„æ•°æ®ã€‚



##### mapå¦‚ä½•ç¼©å®¹ï¼Ÿ

`go` é‡Œçš„ `map` ä¸ä¼šç¼©å®¹ï¼Œæœ€å¤šç­‰é‡æ‰©å®¹ã€‚å› æ­¤å¦‚æœå¤§é‡æ’å…¥ã€å†å¤§é‡åˆ é™¤ `key` çš„è¯ï¼Œä¼šæµªè´¹å†…å­˜ã€‚





#### å‚è€ƒ

> [Stefno - æ·±åº¦è§£å¯†Goè¯­è¨€ä¹‹ map](https://zhuanlan.zhihu.com/p/66676224)
>
> [å¥ ã® éšç¬” - ä½ ä¸çŸ¥é“çš„Golang map](https://www.cnblogs.com/sunsky303/p/11815172.html)
>
> [tptppp - Rediså’ŒGoä¸­mapçš„å¼‚åŒ](https://blog.csdn.net/tptpppp/article/details/103510214)
>
> [darveness - 3.3 å“ˆå¸Œè¡¨](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/)

