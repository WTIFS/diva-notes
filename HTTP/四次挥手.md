#### 四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这由 `TCP` 的半关闭（half-close）造成的。所谓的半关闭，其实就是 `TCP` 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

`TCP` 的四次挥手，客户端或服务器均可主动发起。

刚开始双方都处于 `ESTABLISHED` 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：



##### 第一次挥手

客户端发送一个 `FIN` 报文，报文中会指定一个序列号 `SEQ`，停止发送数据。进入 `FIN_WAIT1` 状态。



##### 第二次挥手

服务端收到 `FIN` 之后，会回复 `ACK` 报文，且把客户端的 `序列号值 SEQ +1` 作为 `ACK` 的值，表明已经收到客户端的报文了，进入 `CLOSE_WAIT` 状态。

客户端收到服务端的确认后，进入 `FIN_WAIT2` 状态，等待服务端发送完剩余的数据。此时的TCP处于半关闭状态。



##### 第三次挥手

服务端没有数据发给客户端后，也向客户端发送 `FIN` 报文，进入 `LAST_ACK` 状态，等待客户端最后的确认。

四次挥手比三次握手多一步，就是把三次握手里的第二次拆成了四次挥手里的第二、三次。因为服务端收到客户端的 `FIN` 后，可能有数据还没发完，所以只能先回复一个 `ACK` 报文。等到数据都发完了，才能发送 `FIN` 报文。



##### 第四次挥手

客户端收到 `FIN` 之后，一样发送一个 `ACK` 报文作为应答，把服务端的 `SEQ +1` 作为自己 `ACK` 报文的序列号值，进入 `TIME_WAIT` 状态。

需要等待 `2MSL` （`Maximum Segment Lifetime`，最大报文生存时间）以确保服务端收到 `ACK` 报文之后才会进入 `CLOSED` 状态，服务端收到 `ACK` 报文之后，就关闭连接了，进入 `CLOSED` 状态。

如果服务端没有收到这次 `ACK`，会重发 `FIN`。客户端从发出 `ACK`，到收到服务的重发的 `FIN`，是两个网络来回，因此等待时间是 `2MSL`。

如果没有这次挥手，那客户端收 `FIN` 的过程可能失败，就会一直处于 `FIN_WAIT2` 状态。



![img](assets/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg)



#### 参考

> [GitHubPorn - 关于三次握手和四次挥手](https://www.zhihu.com/question/271701044/answer/1935194322)

