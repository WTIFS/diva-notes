# 隔离级别

1. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
2. Read committed (读已提交)：可避免脏读的发生。
3. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。`MySQL` 默认隔离级别。
4. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。



#### 提交读 READ UNCOMMITTED

在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。



#### 提交读 READ COMMITTED

多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能"看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。

##### 不可重复读
- 线程 `T1` 读数据后，`T2` 更新了数据，`T1` 再读数据，发现和之前的不一样
- 解决：`RR` 隔离级别下的 `MVCC`



#### 可重复读 REPEATABLE READ（MySQL默认的隔离级别）

可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻读。`InnoDB` 存储引擎通过多版本并发控制 `MVCC` 解决幻读的问题。
##### 幻读

- 线程 `T1` 更新了 `id <= 2` 数据，`T2` 插了条新的 `id=2` 的数据，`T1` 再读数据，会发现有一条没有被更新
- `MVCC` 的解决方式是，`T1` 第二次读的时候，不让它读到 `id=2` 的数据。
- 也可以在 `T1` 里使用间隙锁，锁定 `<=2` 区间的读，使 `T2` 阻塞，`T1` 完成后再执行 `T2`



#### 可串行化 SERIALIZABLE

最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。











