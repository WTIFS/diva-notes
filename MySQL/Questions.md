**MySQL通过什么样的机制保证事务原子性？**
  - 日志。REDO / UNDO log



**MySQL的排序过程是什么样的？**

  - 排序字段命中索引：索引本身就是有序的，顺序遍历即可
  - 未命中索引：Using filesort
    - 数据量小时，内存排序（快排）
    - 数据量大时，外部文件排序（归并排序）
    - 如果有LIMIT，会用大根堆 / 小根堆做堆排
    - 缓存区大小由参数配置



**MySQL里都有哪些锁**

- 分享锁/读锁（Shared Locks）、排他锁/写锁（Exclusive Locks）、间隙锁、行锁（Record Locks）、表锁

- 读未提交是没有加任何锁的，对于它来说也就是没有隔离的效果，所以它的性能也是最好的
- 串行加的是一把大锁，读的时候加共享锁，不能写，写的时候，加的是排它锁，阻塞其它事务的写入和读取，若是其它的事务长时间不能写入就会报超时
- 共享锁是针对同一份数据，多个读操作可以同时进行，不能写但可并行读
- 排他锁针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞
- 行锁和表锁，是从锁的粒度上进行划分的，行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务
- 表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低
- 间隙锁则分为两种：`Gap Locks` 和 `Next-Key Locks`。`Gap Locks` 会锁住两个索引之间的区间，比如 `select * from User where id>3 and id<5 for update`，就会在区间（3，5）之间加锁
- `Next-Key Locks` 是 `Gap Locks + Record Locks` 形成闭区间锁，比如 `select * from User where id>=3 and id=<5 for update`，就会在区间[3,5]之间加锁



**假如两个事务执行写操作，怎么保证并发**

- 假如事务1和事务2都要执行update操作
  - 命中索引的情况下，事务1先update数据行的时候，先会获取行锁，锁定数据，当事务2要进行update操作的时候，也会取获取该数据行的行锁，但是已经被事务1占有，事务2只能等待
  - 若是没有索引的条件下，就获取所有行，都加上行锁，然后MySQL会再次过滤符合条件的的行并释放锁，只有符合条件的行才会继续持有锁