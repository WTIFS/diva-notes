# 原理

##### Redis 为什么快

  - 基于内存
  - 单线程，省去了很多上下文切换线程的时间，也不需要竞争锁
  - 数据结构简单、高效
  - 利用 IO多路复用监听事件、事件驱动



##### 为什么采用单线程？

- 首先必须明确，`redis` 单线程指的是网络请求模块使用了一个线程，其他模块有的用的是多线程，比如并不是一个线程完成了所有功能。
- 原理上，其采用了利用 `epoll` 的多路复用特性，因此可以采用单线程处理其网络请求。
- `6.0` 以后，使用了多线程处理网络读和写。



##### Redis数据类型

- `String`：字符串类型，最简单的类型 
- `Hash`：类似于 `Map` 的一种结构。
- `List`：有序列表。
- `Set`：无序集合。
- `ZSet`：带权值的无序集合，即每个 `ZSet` 元素还另有一个数字代表权值，集合通过权值进行排序。



##### 什么情况下使用 redis

1. 针对热点数据进行缓存
2. 对于特定限时数据的存放
3. 针对带热点权值数据的排序 `list`
4. 分布式锁



##### 与memcache的区别

1. `redis` 处理网络请求采用单线程模型，而 `memcache` 采用多线程异步IO的方式
2. `redis` 支持数据持久化，`memcache` 不支持
3. `redis` 支持的数据格式比 `memcache` 更多（一般选型都是这个原因）





# 数据淘汰

##### 数据淘汰机制

- `volatile-lru` 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- `volatile-ttl` 从已设置过期时间的数据集中挑选将要过期的数据淘汰
- `volatile-random` 从已设置过期时间的数据集中任意选择数据淘汰
- `allkeys-lru` 从所有数据集中挑选最近最少使用的数据淘汰
- `allkeys-random` 从所有数据集中任意选择数据进行淘汰
- `noeviction` 不驱逐数据，禁止所有新的写入





# 穿透、击穿、雪崩

#### 缓存穿透

缓存穿透指缓存和数据库均没有需要查询的数据，攻击者不断发送这种请求，使数据库压力过大。

##### 解决方法

1. 在数据库操作访问前进行校验，对不合法请求直接返回。
2. 对于经常被访问的，并且数据库没有的键，缓存层记录键=null。不过这个得设过期时间，防止数据不一致。



#### 缓存击穿

缓存击穿指某缓存数据时间到期，但由于并发访问该数据的请求特别多，导致大量请求打到数据库

**解决方法**

1. 设置热点数据永远不过期。
2. 读数据库时加锁，降低并发性。



#### 缓存雪崩

缓存雪崩指缓存中一大批数据同时到过期时间。导致大量请求打到数据库

**解决方法**

1. 缓存数据设置随机过期时间，防止同一时间大量数据过期。
2. 设置热点数据永远不过期。





# 高可用

**Redis有哪些集群部署方式**

1. 主从复制
2. 哨兵模式
3. `cluster` 集群模式



**简述主从复制模式**

在主从复制中，有主库（Master）节点和从库（Slave）节点两个角色。从节点服务启动会连接主库，并向主库发送SYNC命令。

主节点收到同步命令，启动持久化工作，工作执行完成后，主节点将传送整个数据库文件到从库，从节点接收到数据库文件数据之后将数据进行加载。此后，主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给从节点，从节点依次执行，从而达到最终的数据同步。

通过这种方式，可以使写操作作用于主库，而读操作作用于从库，从而达到读写分离。



**简述哨兵模式**

哨兵模式监控redis集群中Master的工作的状态。在Master主服务器宕机时，从slave中选择新机器当作master，保证系统高可用。

每个哨兵每10秒向主服务器，slave和其他哨兵发送ping。

客户端通过哨兵，由哨兵提供可供服务的redis master节点。

哨兵只需要配master节点，会自动寻找其对应的slave节点。

监控同一master节点的哨兵会自动互联，组成哨兵网络，当任一哨兵发现master连接不上，即开会投票，投票半数以上决定Master下线，并从slave节点中选取master节点。



**cluster集群**

cluster提出了虚拟槽的概念。

1. redis cluster默认有16384个槽。
2. 如果目前redis执行set操作，redis先对这个key经过CRC16 hash运算，并把结果对16384取余，得到槽编号。
3. 根据槽编号，寻找到其对应的redis节点，在节点上执行hash命令。
4. 如果此时执行get操作，节点先验证该key对应的槽编号是不是归本节点管，如果是则执行操作。如果不是，则发送正确节点编号给客户端。





# 持久化

##### 简述Redis的 RDB

`RDB` 即将当前数据生成快照，并保存于硬盘中。可以通过手动命令，也可以设置自动触发。



##### 简述 Redis 的 save 命令

`save` 命令是 `redis` 手动触发 `RDB` 过程的命令。使用该命令后，服务器阻塞，直到 `RDB` 过程完成后终止。该过程占用内存较多。



##### 简述 Redis 的 bgsave 命令

`bgsave` 命令不阻塞主进程（也不是全程不阻塞，详看下面过程），该命令 `fork` 一个子进程用于执行 `RDB` 过程。其具体过程为：

1. 判断此时有没有子进程用于 `RDB`，有的话直接返回。
2. `redis` 进行 `fork` 子进程过程，此时父进程处于阻塞状态。
3. 子进程创建 `RDB` 文件，完成后返回给父进程



##### 简述Redis自动触发RDB机制

1. 通过配置文件，设置一定时间后自动触发 `RDB`
2. 如采用主从复制过程，主节点自动执行 `bgsave` 生成 `RDB` 并发送给从节点
3. 默认执行 `shutdown` 时，在未开启 `AOF` 后会自动执行 `bgsave`



##### 简述 Redis 的 AOF

`AOF` 通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。可以通过配置文件打开 `AOF`。



##### 简述 AOF 的持久化策略

`AOF` 写日志时并不是直接写到硬盘上，而是先写内存缓冲区，再写入硬盘。写入硬盘的实际可以配置三种：

1. `always`。每执行一次数据修改命令就将其命令写入到磁盘日志文件上。
2. `everysec`。每秒将命令写入到磁盘日志文件上（默认）。
3. `no`。不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。



##### 简述 AOF 的重写

随着客户端不断进行操作，`AOF` 对应的文件也越来越大。`redis` 提供了 `bgrewriteaof` 函数， 把 `redis` 进程内的数据转化为写命令同步到新 `AOF` 文件，减小文件体积。

可以通过配置设置触发阈值。



##### RDB 与 AOF 优缺点比较

`RDB` 是物理日志，优势是体积小，内部用了 `LZF` 压缩。并且加载 `RDB` 恢复速度也远高于 `AOF`。

`AOF`是逻辑日志，备份对系统的消耗比较低，写入快，实时性好。



# 参考

[后端技术小牛说](https://mp.weixin.qq.com/s/paHphwGFE9AsJFWkayZkCg)