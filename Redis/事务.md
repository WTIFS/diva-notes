# MULTI

使用 `MULTI` + `EXEC` 命令可以将一批命令一起执行。如：

``` bash
MULTI     // 开启事务
SET foo 0 
INCR foo
testtest  // 错误命令1
EXEC      // 提交事务
```

但坑的是，执行期间如果有命令报错了，是不会回滚的。比如上面的 `testtest` 命令并不存在，也会报错，但之前的 `foo` 命令会正常执行。

所以 `MULTI` 其实不算事务，从名字上看也是，不过是批量罢了。





# WATCH

使用 `WACTH` 命令可以监视一个 `key`。配合 `MULTI` 可以达到，在 `MULTI` 期间，如果 `key` 的值发生变化，进行回滚的效果。

不过由于还是用了 `MULTI` 的命令，所以并不能避免上面 `MULTI` 本身的问题。





# LUA

`redis` 还提供了`eval` / `evalsha` 命令来执行 `Lua` 脚本。 首先要将 `Lua` 脚本加载到 `redis` 服务端， 得到该脚本的 `SHA1` 校验和，`evalsha` 命令使用 `SHA1` 作为参数可以直接执行对应Lua脚本， 避免每次发送 `Lua` 脚本的开销。 这样客户端就不需要每次执行脚本内容， 而脚本也会常驻在服务端， 脚本功能得到了复用。

`Lua` 脚本功能为 `redis` 开发和运维人员带来如下三个好处：

1. `Lua` 脚本在Redis中是原子执行的， 执行过程中间不会插入其他命令。
2. `Lua` 脚本可以帮助开发和运维人员创造出自己定制的命令， 并可以将这些命令常驻在 `redis` 内存中， 实现复用的效果。
3. `Lua` 脚本可以将多条命令一次性打包， 有效地减少网络开销。

